["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","A lazy tree data structure used for shrinking.","~:file","clojure/test/check/rose_tree.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",33],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",["~$seq","~$remove","~$filter"]],"~:name","~$clojure.test.check.rose-tree","~:reader-aliases",["^ "],"~:imports",null,"~:requires",["^ ","^=","^=","~$core","^=","~$goog","^J"],"~:seen",["^@",["~:require"]],"~:shadow/js-access-global",["^@",["Infinity","Error"]],"~:uses",null,"~:defs",["^ ","~$bifurcate",["^ ","~:protocol-inline",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",139,"^6",17,"^7",139,"^8",26,"~:private",true,"~:arglists",["~#list",["~$quote",["^T",[["~$f","~$roses"]]]]],"^3","Returns a sequence of rose trees representing shrinks that discard\n  half of the vector of roses."],"^R",true,"^D","~$clojure.test.check.rose-tree/bifurcate","^4","clojure/test/check/rose_tree.cljc","^8",26,"~:method-params",["^T",[["~$f","^V"]]],"~:protocol-impl",null,"~:arglists-meta",["^T",[null,null]],"^6",1,"~:variadic?",false,"^5",139,"~:ret-tag",["^@",["~$cljs.core/LazySeq","~$clj-nil"]],"^7",139,"~:max-fixed-arity",2,"~:fn-var",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]],"^3","Returns a sequence of rose trees representing shrinks that discard\n  half of the vector of roses."],"^A",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",185,"^6",7,"^7",185,"^8",10,"^S",["^T",["^U",["^T",[["~$rose"]]]]],"^3","Create a lazy-seq of all of the (unique) nodes in a shrink-tree.\n  This assumes that two nodes with the same value have the same children.\n  While it's not common, it's possible to create trees that don't\n  fit that description. This function is significantly faster than\n  brute-force enumerating all of the nodes in a tree, as there will\n  be many duplicates."],"^D","~$clojure.test.check.rose-tree/seq","^4","clojure/test/check/rose_tree.cljc","^8",10,"^X",["^T",[["^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",185,"^10","^11","^7",185,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Create a lazy-seq of all of the (unique) nodes in a shrink-tree.\n  This assumes that two nodes with the same value have the same children.\n  While it's not common, it's possible to create trees that don't\n  fit that description. This function is significantly faster than\n  brute-force enumerating all of the nodes in a tree, as there will\n  be many duplicates."],"~$pure",["^ ","~:no-doc",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",67,"^6",7,"^7",67,"^8",11,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^3","Puts a value `x` into a Rose tree, with no children.","^18",true],"^D","~$clojure.test.check.rose-tree/pure","^4","clojure/test/check/rose_tree.cljc","^8",11,"^X",["^T",[["~$x"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",67,"^10","~$clojure.test.check.rose-tree/RoseTree","^7",67,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^3","Puts a value `x` into a Rose tree, with no children."],"~$->RoseTree",["^ ","^Q",null,"^2",["^ ","~:protocols",["^@",["~$cljs.core/IIndexed"]],"^4","clojure/test/check/rose_tree.cljc","^8",18,"^6",10,"~:factory","~:positional","^5",15,"^7",15,"^S",["^T",["^U",["^T",[["~$root","~$children"]]]]],"~:skip-protocol-flag",["^@",["^1="]],"^3","Positional factory function for clojure.test.check.rose-tree/RoseTree."],"^1<",["^@",["^1="]],"^D","~$clojure.test.check.rose-tree/->RoseTree","^4","clojure/test/check/rose_tree.cljc","^8",18,"^X",["^T",[["^1@","^1A"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^1>","^1?","^5",15,"^10","^1:","^7",15,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["^1@","^1A"]]]]],"^1B",["^@",["^1="]],"^3","Positional factory function for clojure.test.check.rose-tree/RoseTree."],"~$make-stack",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",179,"^6",8,"^7",179,"^8",18,"^R",true,"^S",["^T",["^U",["^T",[["^1A","~$stack"]]]]]],"^R",true,"^D","~$clojure.test.check.rose-tree/make-stack","^4","clojure/test/check/rose_tree.cljc","^8",18,"^X",["^T",[["^1A","^1E"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",179,"^10",["^@",[null,"~$clj"]],"^7",179,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["^1A","^1E"]]]]]],"~$join",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",55,"^6",7,"^7",55,"^8",11,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Turn a tree of trees into a single tree. Does this by concatenating\n  children of the inner and outer trees.","^18",true],"^D","~$clojure.test.check.rose-tree/join","^4","clojure/test/check/rose_tree.cljc","^8",11,"^X",["^T",[["^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",55,"^10","^1:","^7",55,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Turn a tree of trees into a single tree. Does this by concatenating\n  children of the inner and outer trees."],"~$bind",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",79,"^6",7,"^7",79,"^8",11,"^S",["^T",["^U",["^T",[["~$m","~$k"]]]]],"^3","Takes a Rose tree (m) and a function (k) from\n  values to Rose tree and returns a new Rose tree.\n  This is the monadic bind (>>=) for Rose trees.","^18",true],"^D","~$clojure.test.check.rose-tree/bind","^4","clojure/test/check/rose_tree.cljc","^8",11,"^X",["^T",[["~$m","~$k"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",79,"^10","^1:","^7",79,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$m","~$k"]]]]],"^3","Takes a Rose tree (m) and a function (k) from\n  values to Rose tree and returns a new Rose tree.\n  This is the monadic bind (>>=) for Rose trees."],"^1A",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",35,"^6",7,"^7",35,"^8",15,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Returns the children of the root of the Rose tree.","^18",true],"^D","~$clojure.test.check.rose-tree/children","^4","clojure/test/check/rose_tree.cljc","^8",15,"^X",["^T",[["^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",35,"^10","~$any","^7",35,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Returns the children of the root of the Rose tree."],"~$exclude-nth",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",45,"^6",8,"^7",45,"^8",19,"^R",true,"^S",["^T",["^U",["^T",[["~$n","~$coll"]]]]],"^3","Exclude the nth value in a collection."],"^R",true,"^D","~$clojure.test.check.rose-tree/exclude-nth","^4","clojure/test/check/rose_tree.cljc","^8",19,"^X",["^T",[["~$n","^1O"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",45,"^10","^11","^7",45,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$n","^1O"]]]]],"^3","Exclude the nth value in a collection."],"^B",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",115,"^6",7,"^7",115,"^8",13,"^S",["^T",["^U",["^T",[["^V"]]]]],"^18",true],"^D","~$clojure.test.check.rose-tree/remove","^4","clojure/test/check/rose_tree.cljc","^8",13,"^X",["^T",[["^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",115,"^10","^11","^7",115,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^V"]]]]]],"~$permutations",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",97,"^6",7,"^7",97,"^8",19,"^S",["^T",["^U",["^T",[["^V"]]]]],"^3","Create a seq of vectors, where each rose in turn, has been replaced\n  by its children.","^18",true],"^D","~$clojure.test.check.rose-tree/permutations","^4","clojure/test/check/rose_tree.cljc","^8",19,"^X",["^T",[["^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",97,"^10","^11","^7",97,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^V"]]]]],"^3","Create a seq of vectors, where each rose in turn, has been replaced\n  by its children."],"~$RoseTree",["^ ","~:num-fields",2,"^1<",["^@",["^1="]],"^D","^1:","^4","clojure/test/check/rose_tree.cljc","^8",18,"~:type",true,"^6",10,"^5",15,"~:record",false,"^7",15,"~:tag","~$function","^1B",["^@",["^1="]]],"~$shrink",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",129,"^6",7,"^7",129,"^8",13,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]],"^18",true],"^D","~$clojure.test.check.rose-tree/shrink","^4","clojure/test/check/rose_tree.cljc","^8",13,"^X",["^T",[["~$f","^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",129,"^10","^1:","^7",129,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]]],"~$shrink-vector*",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",151,"^6",17,"^7",151,"^8",31,"^R",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]]],"^R",true,"^D","~$clojure.test.check.rose-tree/shrink-vector*","^4","clojure/test/check/rose_tree.cljc","^8",31,"^X",["^T",[["~$f","^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",151,"^10","^1:","^7",151,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]]],"~$make-rose",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",41,"^6",7,"^7",41,"^8",16,"^S",["^T",["^U",["^T",[["^1@","^1A"]]]]]],"^D","~$clojure.test.check.rose-tree/make-rose","^4","clojure/test/check/rose_tree.cljc","^8",16,"^X",["^T",[["^1@","^1A"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",41,"^10","^1:","^7",41,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["^1@","^1A"]]]]]],"^C",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",87,"^6",7,"^7",87,"^8",13,"^S",["^T",["^U",["^T",[["~$pred","^15"]]]]],"^3","Returns a new Rose tree whose values pass `pred`. Values who\n  do not pass `pred` have their children cut out as well.\n  Takes a list of roses, not a rose","^18",true],"^D","~$clojure.test.check.rose-tree/filter","^4","clojure/test/check/rose_tree.cljc","^8",13,"^X",["^T",[["^24","^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",87,"^10","^1:","^7",87,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["^24","^15"]]]]],"^3","Returns a new Rose tree whose values pass `pred`. Values who\n  do not pass `pred` have their children cut out as well.\n  Takes a list of roses, not a rose"],"^1@",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",29,"^6",7,"^7",29,"^8",11,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Returns the root of a Rose tree.","^18",true],"^D","~$clojure.test.check.rose-tree/root","^4","clojure/test/check/rose_tree.cljc","^8",11,"^X",["^T",[["^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",29,"^10","^1M","^7",29,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Returns the root of a Rose tree."],"~$shrink-vector",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",157,"^6",7,"^7",157,"^8",20,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]]],"^D","~$clojure.test.check.rose-tree/shrink-vector","^4","clojure/test/check/rose_tree.cljc","^8",20,"^X",["^T",[["~$f","^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",157,"^10","^1:","^7",157,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]]],"~$zip",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",106,"^6",7,"^7",106,"^8",10,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]],"^3","Apply `f` to the sequence of Rose trees `roses`.","^18",true],"^D","~$clojure.test.check.rose-tree/zip","^4","clojure/test/check/rose_tree.cljc","^8",10,"^X",["^T",[["~$f","^V"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",106,"^10","^1:","^7",106,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]],"^3","Apply `f` to the sequence of Rose trees `roses`."],"~$fmap",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",73,"^6",7,"^7",73,"^8",11,"^S",["^T",["^U",["^T",[["~$f","^15"]]]]],"^3","Applies functions `f` to all values in the tree.","^18",true],"^D","~$clojure.test.check.rose-tree/fmap","^4","clojure/test/check/rose_tree.cljc","^8",11,"^X",["^T",[["~$f","^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",73,"^10","^1:","^7",73,"^13",2,"^14",true,"^S",["^T",["^U",["^T",[["~$f","^15"]]]]],"^3","Applies functions `f` to all values in the tree."],"~$unchunk",["^ ","^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",122,"^6",17,"^7",122,"^8",24,"^R",true,"^S",["^T",["^U",["^T",[["~$a-lazy-seq"]]]]],"^3","Returns an equivalent lazy seq that is not chunked."],"^R",true,"^D","~$clojure.test.check.rose-tree/unchunk","^4","clojure/test/check/rose_tree.cljc","^8",24,"^X",["^T",[["^2>"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",122,"^10","^11","^7",122,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^2>"]]]]],"^3","Returns an equivalent lazy seq that is not chunked."],"~$collapse",["^ ","^18",true,"^Q",null,"^2",["^ ","^4","clojure/test/check/rose_tree.cljc","^5",167,"^6",7,"^7",167,"^8",15,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Return a new rose-tree whose depth-one children\n  are the children from depth one _and_ two of the input\n  tree.","^18",true],"^D","~$clojure.test.check.rose-tree/collapse","^4","clojure/test/check/rose_tree.cljc","^8",15,"^X",["^T",[["^15"]]],"^Y",null,"^Z",["^T",[null,null]],"^6",1,"^[",false,"^5",167,"^10","^1:","^7",167,"^13",1,"^14",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^3","Return a new rose-tree whose depth-one children\n  are the children from depth one _and_ two of the input\n  tree."]],"~:require-macros",["^ ","^=","^=","^I","^="],"~:cljs.analyzer/constants",["^ ","^K",["^@",["~:else","^1A","^1@"]],"~:order",["^2D","^1@","^1A"]],"~:flags",["^ ","^L",["^@",[]]],"~:js-deps",[],"~:deps",["^J","^="]]