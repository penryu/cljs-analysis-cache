["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check/random.cljs","~:line",12,"~:column",2,"~:end-line",12,"~:end-column",27,"~:author","Gary Fredericks","~:doc","Purely functional and splittable pseudo-random number generators."],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:shadow/protocol-prefixes",["~#set",["clojure$test$check$random$IRandom$"]],"~:use-macros",null,"~:excludes",["^@",["~$bit-count","~$bit-xor","~$unsigned-bit-shift-right","~$*","~$bit-or","~$+"]],"~:name","~$clojure.test.check.random","~:reader-aliases",["^ "],"~:imports",null,"~:requires",["^ ","~$clojure.test.check.random.doubles","^L","~$doubles","^L","~$clojure.test.check.random.longs","^N","~$longs","^N","^>","^>","~$goog","^P"],"~:seen",["^@",["~:require"]],"~:shadow/js-access-global",["^@",["Date","Error"]],"~:uses",["^ ","~$+","^N","~$*","^N","^D","^N","^F","^N","^C","^N","^E","^N"],"~:defs",["^ ","~$mix-gamma-const-1",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",71,"^5",16,"^6",71,"^7",33,"~:private",true],"^W",true,"^G","~$clojure.test.check.random/mix-gamma-const-1","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",71,"^6",71,"~:tag","~$js"],"~$make-java-util-splittable-random",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",123,"^5",7,"^6",123,"^7",39,"~:arglists",["~#list",["~$quote",["^12",[["~$seed"]]]]]],"^G","~$clojure.test.check.random/make-java-util-splittable-random","^3","clojure/test/check/random.cljs","^7",39,"~:method-params",["^12",[["^14"]]],"~:protocol-impl",null,"~:arglists-meta",["^12",[null,null]],"^5",1,"~:variadic?",false,"^4",123,"~:ret-tag","~$clojure.test.check.random/JavaUtilSplittableRandom","^6",123,"~:max-fixed-arity",1,"~:fn-var",true,"^11",["^12",["^13",["^12",[["^14"]]]]]],"~$rand-long",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",20,"^5",4,"^6",20,"^7",13,"~:protocol","~$clojure.test.check.random/IRandom","^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^11",["^12",["^13",["^12",[["~$rng"]]]]]],"^1?","^1@","^G","~$clojure.test.check.random/rand-long","^3","clojure/test/check/random.cljs","^7",13,"^16",["^12",[["^1A"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",19,"^1:","~$any","^6",20,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["^1A"]]]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",62,"^5",17,"^6",62,"^7",23,"^W",true,"^11",["^12",["^13",["^12",[["~$n"]]]]]],"^W",true,"^G","~$clojure.test.check.random/mix-64","^3","clojure/test/check/random.cljs","^7",23,"^16",["^12",[["~$n"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",62,"^1:","^1C","^6",62,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["~$n"]]]]]],"~$golden-gamma",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",120,"^5",16,"^6",120,"^7",28,"^W",true],"^W",true,"^G","~$clojure.test.check.random/golden-gamma","^3","clojure/test/check/random.cljs","^7",28,"^5",1,"^4",120,"^6",120,"^Y","^Z"],"~$mix-gamma-const-2",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",72,"^5",16,"^6",72,"^7",33,"^W",true],"^W",true,"^G","~$clojure.test.check.random/mix-gamma-const-2","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",72,"^6",72,"^Y","^Z"],"~$mix-64-const-2",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",60,"^5",16,"^6",60,"^7",30,"^W",true],"^W",true,"^G","~$clojure.test.check.random/mix-64-const-2","^3","clojure/test/check/random.cljs","^7",30,"^5",1,"^4",60,"^6",60,"^Y","^Z"],"~$bxoubsr",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",54,"^5",17,"^6",54,"^7",24,"^W",true,"^11",["^12",["^13",["^12",[["~$x","~$n"]]]]],"^9","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"^W",true,"^G","~$clojure.test.check.random/bxoubsr","^3","clojure/test/check/random.cljs","^7",24,"^16",["^12",[["~$x","~$n"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",54,"^1:","^1C","^6",54,"^1<",2,"^1=",true,"^11",["^12",["^13",["^12",[["~$x","~$n"]]]]],"^9","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"~$make-random",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",139,"^5",7,"^6",139,"^7",18,"^11",["^12",["^13",["^12",[[],["^14"]]]]],"^9","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol.","~:top-fn",["^ ","^19",false,"~:fixed-arity",1,"^1<",1,"^16",[[],["^14"]],"^11",["^12",[[],["^14"]]],"^18",["^12",[null,null]]]],"^G","~$clojure.test.check.random/make-random","^3","clojure/test/check/random.cljs","^7",18,"^1O",["^ ","^19",false,"^1P",1,"^1<",1,"^16",[[],["^14"]],"^11",["^12",[[],["^14"]]],"^18",["^12",[null,null]]],"^16",[[],["^14"]],"^17",null,"^1P",1,"^18",["^12",[null,null]],"^5",1,"^19",false,"~:methods",[["^ ","^1P",0,"^19",false,"^Y","^1C"],["^ ","^1P",1,"^19",false,"^Y","^1;"]],"^4",139,"^6",139,"^1<",1,"^1=",true,"^11",["^12",[[],["^14"]]],"^9","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol."],"~$mix-gamma",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",75,"^5",17,"^6",75,"^7",26,"^W",true,"^11",["^12",["^13",["^12",[["~$n"]]]]]],"^W",true,"^G","~$clojure.test.check.random/mix-gamma","^3","clojure/test/check/random.cljs","^7",26,"^16",["^12",[["~$n"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",75,"^1:","^1C","^6",75,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["~$n"]]]]]],"~$mix-gamma-const-3",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",73,"^5",16,"^6",73,"^7",33,"^W",true],"^W",true,"^G","~$clojure.test.check.random/mix-gamma-const-3","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",73,"^6",73,"^Y","^Z"],"~$split-n",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",37,"^5",4,"^6",37,"^7",11,"^1?","^1@","^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^11",["^12",["^13",["^12",[["^1A","~$n"]]]]]],"^1?","^1@","^G","~$clojure.test.check.random/split-n","^3","clojure/test/check/random.cljs","^7",11,"^16",["^12",[["^1A","~$n"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",19,"^1:","^1C","^6",37,"^1<",2,"^1=",true,"^11",["^12",["^13",["^12",[["^1A","~$n"]]]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$next-rng",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",130,"^5",16,"^6",130,"^7",24,"^W",true],"^W",true,"^G","~$clojure.test.check.random/next-rng","^3","clojure/test/check/random.cljs","^7",24,"^5",1,"^4",130,"^6",130,"^Y","~$function"],"~$hex-long",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",49,"^5",17,"^6",49,"^7",25,"^W",true,"^11",["^12",["^13",["^12",[["~$s"]]]]],"^9","Helper for defining constants."],"^W",true,"^G","~$clojure.test.check.random/hex-long","^3","clojure/test/check/random.cljs","^7",25,"^16",["^12",[["~$s"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",49,"^1:","^Z","^6",49,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["~$s"]]]]],"^9","Helper for defining constants."],"~$rand-double",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",25,"^5",4,"^6",25,"^7",15,"^1?","^1@","^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^11",["^12",["^13",["^12",[["^1A"]]]]]],"^1?","^1@","^G","~$clojure.test.check.random/rand-double","^3","clojure/test/check/random.cljs","^7",15,"^16",["^12",[["^1A"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",19,"^1:","^1C","^6",25,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["^1A"]]]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64-const-1",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",59,"^5",16,"^6",59,"^7",30,"^W",true],"^W",true,"^G","~$clojure.test.check.random/mix-64-const-1","^3","clojure/test/check/random.cljs","^7",30,"^5",1,"^4",59,"^6",59,"^Y","^Z"],"~$split",["^ ","^10",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",31,"^5",4,"^6",31,"^7",9,"^1?","^1@","^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^11",["^12",["^13",["^12",[["^1A"]]]]]],"^1?","^1@","^G","~$clojure.test.check.random/split","^3","clojure/test/check/random.cljs","^7",9,"^16",["^12",[["^1A"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^4",19,"^1:","^1C","^6",31,"^1<",1,"^1=",true,"^11",["^12",["^13",["^12",[["^1A"]]]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$JavaUtilSplittableRandom",["^ ","~:num-fields",2,"~:protocols",["^@",["^1@"]],"^G","^1;","^3","clojure/test/check/random.cljs","^7",34,"~:type",true,"^5",10,"^4",91,"~:record",false,"^6",91,"^Y","^1[","~:skip-protocol-flag",null],"~$IRandom",["^ ","^2",["^ ","~:protocol-symbol",true,"^3","clojure/test/check/random.cljs","^7",21,"^5",14,"^4",19,"~:protocol-info",["^ ","^1R",["^ ","^1>",[["^1A"]],"^22",[["^1A"]],"^26",[["^1A"]],"^1W",[["^1A","~$n"]]]],"^6",19,"~:sigs",["^ ","~:rand-long",["^ ","^G","^1>","^11",["^12",[["^1A"]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:rand-double",["^ ","^G","^22","^11",["^12",[["^1A"]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:split",["^ ","^G","^26","^11",["^12",[["^1A"]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:split-n",["^ ","^G","^1W","^11",["^12",[["^1A","~$n"]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"]],"~:jsdoc",["^12",["@interface"]]],"^2?",true,"^G","^1@","^3","clojure/test/check/random.cljs","^7",21,"^5",1,"^4",19,"^2@",["^ ","^1R",["^ ","^1>",[["^1A"]],"^22",[["^1A"]],"^26",[["^1A"]],"^1W",[["^1A","~$n"]]]],"~:info",null,"^6",19,"^Y","^1C","^2A",["^ ","^2B",["^ ","^G","^1>","^11",["^12",[["^1A"]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2C",["^ ","^G","^22","^11",["^12",[["^1A"]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2D",["^ ","^G","^26","^11",["^12",[["^1A"]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2E",["^ ","^G","^1W","^11",["^12",[["^1A","~$n"]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"]],"~:impls",["^@",["^1;"]],"^2F",["^12",["@interface"]]],"~$->JavaUtilSplittableRandom",["^ ","^10",null,"^2",["^ ","^2:",["^@",["^1@"]],"^3","clojure/test/check/random.cljs","^7",34,"^5",10,"~:factory","~:positional","^4",91,"^6",91,"^11",["^12",["^13",["^12",[["~$gamma","~$state"]]]]],"^2=",null,"^9","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."],"^2:",["^@",["^1@"]],"^G","~$clojure.test.check.random/->JavaUtilSplittableRandom","^3","clojure/test/check/random.cljs","^7",34,"^16",["^12",[["^2L","^2M"]]],"^17",null,"^18",["^12",[null,null]],"^5",1,"^19",false,"^2J","^2K","^4",91,"^1:","^1;","^6",91,"^1<",2,"^1=",true,"^11",["^12",["^13",["^12",[["^2L","^2M"]]]]],"^2=",null,"^9","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."]],"~:require-macros",["^ ","^>","^>"],"~:cljs.analyzer/constants",["^ ","^Q",["^@",["~:returned","~:state","~:seed","^2M","^2L"]],"~:order",["^2L","^2M","^2S","^2R","^2Q"]],"~:flags",["^ ","^R",["^@",[]]],"~:js-deps",[],"~:deps",["^P","^>","^L","^N"]]