["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check/random.cljs","~:line",12,"~:column",2,"~:end-line",12,"~:end-column",27,"~:author","Gary Fredericks","~:doc","Purely functional and splittable pseudo-random number generators."],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:shadow/protocol-prefixes",["~#set",["clojure$test$check$random$IRandom$"]],"~:use-macros",null,"~:excludes",["^@",["~$bit-count","~$bit-xor","~$unsigned-bit-shift-right","~$*","~$bit-or","~$+"]],"~:name","~$clojure.test.check.random","~:imports",null,"~:requires",["^ ","~$clojure.test.check.random.doubles","^K","~$doubles","^K","~$clojure.test.check.random.longs","^M","~$longs","^M","^>","^>","~$goog","^O"],"~:seen",["^@",["~:require"]],"~:shadow/js-access-global",["^@",["Date","Error"]],"~:uses",["^ ","~$+","^M","~$*","^M","^D","^M","^F","^M","^C","^M","^E","^M"],"~:defs",["^ ","~$mix-gamma-const-1",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",71,"^5",16,"^6",71,"^7",33,"~:private",true],"^V",true,"^G","~$clojure.test.check.random/mix-gamma-const-1","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",71,"^6",71,"~:tag","~$any"],"~$make-java-util-splittable-random",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",123,"^5",7,"^6",123,"^7",39,"~:arglists",["~#list",["~$quote",["^11",[["~$seed"]]]]]],"^G","~$clojure.test.check.random/make-java-util-splittable-random","^3","clojure/test/check/random.cljs","^7",39,"~:method-params",["^11",[["^13"]]],"~:protocol-impl",null,"~:arglists-meta",["^11",[null,null]],"^5",1,"~:variadic?",false,"^4",123,"~:ret-tag","~$clojure.test.check.random/JavaUtilSplittableRandom","^6",123,"~:max-fixed-arity",1,"~:fn-var",true,"^10",["^11",["^12",["^11",[["^13"]]]]]],"~$rand-long",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",20,"^5",4,"^6",20,"^7",13,"~:protocol","~$clojure.test.check.random/IRandom","^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^10",["^11",["^12",["^11",[["~$rng"]]]]]],"^1>","^1?","^G","~$clojure.test.check.random/rand-long","^3","clojure/test/check/random.cljs","^7",13,"^15",["^11",[["^1@"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",19,"^19","^Y","^6",20,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["^1@"]]]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",62,"^5",17,"^6",62,"^7",23,"^V",true,"^10",["^11",["^12",["^11",[["~$n"]]]]]],"^V",true,"^G","~$clojure.test.check.random/mix-64","^3","clojure/test/check/random.cljs","^7",23,"^15",["^11",[["~$n"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",62,"^19","^Y","^6",62,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["~$n"]]]]]],"~$golden-gamma",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",120,"^5",16,"^6",120,"^7",28,"^V",true],"^V",true,"^G","~$clojure.test.check.random/golden-gamma","^3","clojure/test/check/random.cljs","^7",28,"^5",1,"^4",120,"^6",120,"^X","^Y"],"~$mix-gamma-const-2",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",72,"^5",16,"^6",72,"^7",33,"^V",true],"^V",true,"^G","~$clojure.test.check.random/mix-gamma-const-2","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",72,"^6",72,"^X","^Y"],"~$mix-64-const-2",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",60,"^5",16,"^6",60,"^7",30,"^V",true],"^V",true,"^G","~$clojure.test.check.random/mix-64-const-2","^3","clojure/test/check/random.cljs","^7",30,"^5",1,"^4",60,"^6",60,"^X","^Y"],"~$bxoubsr",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",54,"^5",17,"^6",54,"^7",24,"^V",true,"^10",["^11",["^12",["^11",[["~$x","~$n"]]]]],"^9","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"^V",true,"^G","~$clojure.test.check.random/bxoubsr","^3","clojure/test/check/random.cljs","^7",24,"^15",["^11",[["~$x","~$n"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",54,"^19","^Y","^6",54,"^1;",2,"^1<",true,"^10",["^11",["^12",["^11",[["~$x","~$n"]]]]],"^9","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"~$make-random",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",139,"^5",7,"^6",139,"^7",18,"^10",["^11",["^12",["^11",[[],["^13"]]]]],"^9","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol.","~:top-fn",["^ ","^18",false,"~:fixed-arity",1,"^1;",1,"^15",[[],["^13"]],"^10",["^11",[[],["^13"]]],"^17",["^11",[null,null]]]],"^G","~$clojure.test.check.random/make-random","^3","clojure/test/check/random.cljs","^7",18,"^1M",["^ ","^18",false,"^1N",1,"^1;",1,"^15",[[],["^13"]],"^10",["^11",[[],["^13"]]],"^17",["^11",[null,null]]],"^15",[[],["^13"]],"^16",null,"^1N",1,"^17",["^11",[null,null]],"^5",1,"^18",false,"~:methods",[["^ ","^1N",0,"^18",false,"^X","^Y"],["^ ","^1N",1,"^18",false,"^X","^1:"]],"^4",139,"^6",139,"^1;",1,"^1<",true,"^10",["^11",[[],["^13"]]],"^9","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol."],"~$mix-gamma",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",75,"^5",17,"^6",75,"^7",26,"^V",true,"^10",["^11",["^12",["^11",[["~$n"]]]]]],"^V",true,"^G","~$clojure.test.check.random/mix-gamma","^3","clojure/test/check/random.cljs","^7",26,"^15",["^11",[["~$n"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",75,"^19","^Y","^6",75,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["~$n"]]]]]],"~$mix-gamma-const-3",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",73,"^5",16,"^6",73,"^7",33,"^V",true],"^V",true,"^G","~$clojure.test.check.random/mix-gamma-const-3","^3","clojure/test/check/random.cljs","^7",33,"^5",1,"^4",73,"^6",73,"^X","^Y"],"~$split-n",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",37,"^5",4,"^6",37,"^7",11,"^1>","^1?","^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^10",["^11",["^12",["^11",[["^1@","~$n"]]]]]],"^1>","^1?","^G","~$clojure.test.check.random/split-n","^3","clojure/test/check/random.cljs","^7",11,"^15",["^11",[["^1@","~$n"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",19,"^19","^Y","^6",37,"^1;",2,"^1<",true,"^10",["^11",["^12",["^11",[["^1@","~$n"]]]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$next-rng",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",130,"^5",16,"^6",130,"^7",24,"^V",true],"^V",true,"^G","~$clojure.test.check.random/next-rng","^3","clojure/test/check/random.cljs","^7",24,"^5",1,"^4",130,"^6",130,"^X","~$function"],"~$hex-long",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",49,"^5",17,"^6",49,"^7",25,"^V",true,"^10",["^11",["^12",["^11",[["~$s"]]]]],"^9","Helper for defining constants."],"^V",true,"^G","~$clojure.test.check.random/hex-long","^3","clojure/test/check/random.cljs","^7",25,"^15",["^11",[["~$s"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",49,"^19","^Y","^6",49,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["~$s"]]]]],"^9","Helper for defining constants."],"~$rand-double",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",25,"^5",4,"^6",25,"^7",15,"^1>","^1?","^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^10",["^11",["^12",["^11",[["^1@"]]]]]],"^1>","^1?","^G","~$clojure.test.check.random/rand-double","^3","clojure/test/check/random.cljs","^7",15,"^15",["^11",[["^1@"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",19,"^19","^Y","^6",25,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["^1@"]]]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64-const-1",["^ ","^2",["^ ","^3","clojure/test/check/random.cljs","^4",59,"^5",16,"^6",59,"^7",30,"^V",true],"^V",true,"^G","~$clojure.test.check.random/mix-64-const-1","^3","clojure/test/check/random.cljs","^7",30,"^5",1,"^4",59,"^6",59,"^X","^Y"],"~$split",["^ ","^[",null,"^2",["^ ","^3","clojure/test/check/random.cljs","^4",31,"^5",4,"^6",31,"^7",9,"^1>","^1?","^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^10",["^11",["^12",["^11",[["^1@"]]]]]],"^1>","^1?","^G","~$clojure.test.check.random/split","^3","clojure/test/check/random.cljs","^7",9,"^15",["^11",[["^1@"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^4",19,"^19","^Y","^6",31,"^1;",1,"^1<",true,"^10",["^11",["^12",["^11",[["^1@"]]]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$JavaUtilSplittableRandom",["^ ","~:num-fields",2,"~:protocols",["^@",["^1?"]],"^G","^1:","^3","clojure/test/check/random.cljs","^7",34,"~:type",true,"^5",10,"^4",91,"~:record",false,"^6",91,"^X","^1Y","~:skip-protocol-flag",null],"~$IRandom",["^ ","^2",["^ ","~:protocol-symbol",true,"^3","clojure/test/check/random.cljs","^7",21,"^5",14,"^4",19,"~:protocol-info",["^ ","^1P",["^ ","^1=",[["^1@"]],"^20",[["^1@"]],"^24",[["^1@"]],"^1U",[["^1@","~$n"]]]],"^6",19,"~:sigs",["^ ","~:rand-long",["^ ","^G","^1=","^10",["^11",[["^1@"]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:rand-double",["^ ","^G","^20","^10",["^11",[["^1@"]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:split",["^ ","^G","^24","^10",["^11",[["^1@"]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~:split-n",["^ ","^G","^1U","^10",["^11",[["^1@","~$n"]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"]],"~:jsdoc",["^11",["@interface"]]],"^2=",true,"^G","^1?","^3","clojure/test/check/random.cljs","^7",21,"^5",1,"^4",19,"^2>",["^ ","^1P",["^ ","^1=",[["^1@"]],"^20",[["^1@"]],"^24",[["^1@"]],"^1U",[["^1@","~$n"]]]],"~:info",null,"^6",19,"^X","^Y","^2?",["^ ","^2@",["^ ","^G","^1=","^10",["^11",[["^1@"]]],"^9","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2A",["^ ","^G","^20","^10",["^11",[["^1@"]]],"^9","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2B",["^ ","^G","^24","^10",["^11",[["^1@"]]],"^9","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"^2C",["^ ","^G","^1U","^10",["^11",[["^1@","~$n"]]],"^9","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"]],"~:impls",["^@",["^1:"]],"^2D",["^11",["@interface"]]],"~$->JavaUtilSplittableRandom",["^ ","^[",null,"^2",["^ ","^28",["^@",["^1?"]],"^3","clojure/test/check/random.cljs","^7",34,"^5",10,"~:factory","~:positional","^4",91,"^6",91,"^10",["^11",["^12",["^11",[["~$gamma","~$state"]]]]],"^2;",null,"^9","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."],"^28",["^@",["^1?"]],"^G","~$clojure.test.check.random/->JavaUtilSplittableRandom","^3","clojure/test/check/random.cljs","^7",34,"^15",["^11",[["^2J","^2K"]]],"^16",null,"^17",["^11",[null,null]],"^5",1,"^18",false,"^2H","^2I","^4",91,"^19","^1:","^6",91,"^1;",2,"^1<",true,"^10",["^11",["^12",["^11",[["^2J","^2K"]]]]],"^2;",null,"^9","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."]],"~:require-macros",["^ ","^>","^>"],"~:cljs.analyzer/constants",["^ ","^P",["^@",["~:returned","~:state","~:seed","^2K","^2J"]],"~:order",["^2J","^2K","^2Q","^2P","^2O"]],"~:flags",["^ ","^Q",["^@",[]]],"~:js-deps",["^ "],"~:deps",["^O","^>","^K","^M"]]