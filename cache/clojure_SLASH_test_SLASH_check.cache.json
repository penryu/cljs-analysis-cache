["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",23],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^D","~$rose","~$clojure.test.check.rose-tree","~$results","^D","~$clojure.test.check.impl","^H","^F","^F","^<","^<","~$clojure.test.check.generators","^I","~$goog","^J","~$gen","^I","~$clojure.test.check.random","^L","~$random","^L"],"~:seen",["^?",["~:require"]],"~:shadow/js-access-global",["^?",["Error"]],"~:uses",["^ ","~$get-current-time-millis","^H"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",157,"^5",8,"^6",157,"^7",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^X",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^V",true,"^@","~$clojure.test.check/shrink-loop","^3","clojure/test/check.cljc","^7",19,"~:method-params",["^X",[["^Z","^["]]],"~:protocol-impl",null,"~:arglists-meta",["^X",[null,null]],"^5",1,"~:variadic?",false,"^4",157,"~:ret-tag","~$cljs.core/IMap","^6",157,"~:max-fixed-arity",2,"~:fn-var",true,"^W",["^X",["^Y",["^X",[["^Z","^["]]]]],"^10","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",212,"^5",8,"^6",212,"^7",15,"^V",true,"^W",["^X",["^Y",["^X",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^["]]]]]],"^V",true,"^@","~$clojure.test.check/failure","^3","clojure/test/check.cljc","^7",15,"^12",["^X",[["^1;","^1<","^1=","^1>","^1?","^1@","^["]]],"^13",null,"^14",["^X",[null,null]],"^5",1,"^15",false,"^4",212,"^16",["^?",["~$clj","~$any"]],"^6",212,"^18",7,"^19",true,"^W",["^X",["^Y",["^X",[["^1;","^1<","^1=","^1>","^1?","^1@","^["]]]]]],"~$make-rng",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",19,"^5",8,"^6",19,"^7",16,"^V",true,"^W",["^X",["^Y",["^X",[["^1?"]]]]]],"^V",true,"^@","~$clojure.test.check/make-rng","^3","clojure/test/check.cljc","^7",16,"^12",["^X",[["^1?"]]],"^13",null,"^14",["^X",[null,null]],"^5",1,"^15",false,"^4",19,"^16","~$cljs.core/IVector","^6",19,"^18",1,"^19",true,"^W",["^X",["^Y",["^X",[["^1?"]]]]]],"~$complete",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",26,"^5",8,"^6",26,"^7",16,"^V",true,"^W",["^X",["^Y",["^X",[["^1;","~$num-trials","^1?","^1@","^["]]]]]],"^V",true,"^@","~$clojure.test.check/complete","^3","clojure/test/check.cljc","^7",16,"^12",["^X",[["^1;","^1H","^1?","^1@","^["]]],"^13",null,"^14",["^X",[null,null]],"^5",1,"^15",false,"^4",26,"^16","^17","^6",26,"^18",5,"^19",true,"^W",["^X",["^Y",["^X",[["^1;","^1H","^1?","^1@","^["]]]]]],"~$legacy-result",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",43,"^5",17,"^6",43,"^7",30,"^V",true,"^W",["^X",["^Y",["^X",[["~$result"]]]]],"^10","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^V",true,"^@","~$clojure.test.check/legacy-result","^3","clojure/test/check.cljc","^7",30,"^12",["^X",[["^1K"]]],"^13",null,"^14",["^X",[null,null]],"^5",1,"^15",false,"^4",43,"^16",["^?",[null,"^1C","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^6",43,"^18",1,"^19",true,"^W",["^X",["^Y",["^X",[["^1K"]]]]],"^10","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",59,"^5",7,"^6",59,"^7",18,"^W",["^X",["^Y",["^X",[["~$num-tests","^1;","~$&",["^ ","~:keys",["^1?","~$max-size","^["],"~:or",["^ ","^1R",200,"^[",["^X",["~$constantly",null]]]]]]]]],"^10","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^15",true,"~:fixed-arity",2,"^18",2,"^12",[["^X",["^1P","^1;",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^W",["^X",[["^1P","^1;","~$&",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^14",["^X",[null]]]],"^@","~$clojure.test.check/quick-check","^3","clojure/test/check.cljc","^7",18,"^1U",["^ ","^15",true,"^1V",2,"^18",2,"^12",[["^X",["^1P","^1;",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^W",["^X",[["^1P","^1;","~$&",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^14",["^X",[null]]],"^12",[["^X",["^1P","^1;",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^13",null,"^1V",2,"^14",["^X",[null]],"^5",1,"^15",true,"~:methods",[["^ ","^1V",2,"^15",true,"~:tag",["^?",["^1C","^17"]]]],"^4",59,"^16","^1C","^6",59,"^18",2,"^19",true,"^W",["^X",[["^1P","^1;","~$&",["^ ","^1Q",["^1?","^1R","^["],"^1S",["^ ","^1R",200,"^[",["^X",["^1T",null]]]]]]],"^10","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^U",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",146,"^5",8,"^6",146,"^7",23,"^V",true,"^W",["^X",["^Y",["^X",[["~$total-nodes-visited","~$depth","~$smallest","^1@"]]]]]],"^V",true,"^@","~$clojure.test.check/smallest-shrink","^3","clojure/test/check.cljc","^7",23,"^12",["^X",[["^1[","^20","^21","^1@"]]],"^13",null,"^14",["^X",[null,null]],"^5",1,"^15",false,"^4",146,"^16","^17","^6",146,"^18",4,"^19",true,"^W",["^X",["^Y",["^X",[["^1[","^20","^21","^1@"]]]]]]],"~:require-macros",["^ ","^<","^<"],"~:cljs.analyzer/constants",["^ ","^N",["^?",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^2?","^2<","^2C","^2J","^2>","^2N","^2A","^2L","^26","^2@","^2I","^25","^2:","^2D","^2F","^29","^2K","^2G","^2E","^2M","^2=","^28","^2B","^2H","^2;","^27"]],"~:flags",["^ ","^O",["^?",[]]],"~:js-deps",["^ "],"~:deps",["^J","^<","^I","^L","^D","^F","^H"]]