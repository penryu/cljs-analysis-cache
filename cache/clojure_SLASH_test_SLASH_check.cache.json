["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",23],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:reader-aliases",["^ "],"~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^E","~$rose","~$clojure.test.check.rose-tree","~$results","^E","~$clojure.test.check.impl","^I","^G","^G","^<","^<","~$clojure.test.check.generators","^J","~$goog","^K","~$gen","^J","~$clojure.test.check.random","^M","~$random","^M"],"~:seen",["^?",["~:require"]],"~:shadow/js-access-global",["^?",["Error"]],"~:uses",["^ ","~$get-current-time-millis","^I"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",157,"^5",8,"^6",157,"^7",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^Y",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^W",true,"^@","~$clojure.test.check/shrink-loop","^3","clojure/test/check.cljc","^7",19,"~:method-params",["^Y",[["^[","^10"]]],"~:protocol-impl",null,"~:arglists-meta",["^Y",[null,null]],"^5",1,"~:variadic?",false,"^4",157,"~:ret-tag","~$cljs.core/IMap","^6",157,"~:max-fixed-arity",2,"~:fn-var",true,"^X",["^Y",["^Z",["^Y",[["^[","^10"]]]]],"^11","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",212,"^5",8,"^6",212,"^7",15,"^W",true,"^X",["^Y",["^Z",["^Y",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^10"]]]]]],"^W",true,"^@","~$clojure.test.check/failure","^3","clojure/test/check.cljc","^7",15,"^13",["^Y",[["^1<","^1=","^1>","^1?","^1@","^1A","^10"]]],"^14",null,"^15",["^Y",[null,null]],"^5",1,"^16",false,"^4",212,"^17",["^?",["~$clj","~$any"]],"^6",212,"^19",7,"^1:",true,"^X",["^Y",["^Z",["^Y",[["^1<","^1=","^1>","^1?","^1@","^1A","^10"]]]]]],"~$make-rng",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",19,"^5",8,"^6",19,"^7",16,"^W",true,"^X",["^Y",["^Z",["^Y",[["^1@"]]]]]],"^W",true,"^@","~$clojure.test.check/make-rng","^3","clojure/test/check.cljc","^7",16,"^13",["^Y",[["^1@"]]],"^14",null,"^15",["^Y",[null,null]],"^5",1,"^16",false,"^4",19,"^17","~$cljs.core/IVector","^6",19,"^19",1,"^1:",true,"^X",["^Y",["^Z",["^Y",[["^1@"]]]]]],"~$complete",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",26,"^5",8,"^6",26,"^7",16,"^W",true,"^X",["^Y",["^Z",["^Y",[["^1<","~$num-trials","^1@","^1A","^10"]]]]]],"^W",true,"^@","~$clojure.test.check/complete","^3","clojure/test/check.cljc","^7",16,"^13",["^Y",[["^1<","^1I","^1@","^1A","^10"]]],"^14",null,"^15",["^Y",[null,null]],"^5",1,"^16",false,"^4",26,"^17","^18","^6",26,"^19",5,"^1:",true,"^X",["^Y",["^Z",["^Y",[["^1<","^1I","^1@","^1A","^10"]]]]]],"~$legacy-result",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",43,"^5",17,"^6",43,"^7",30,"^W",true,"^X",["^Y",["^Z",["^Y",[["~$result"]]]]],"^11","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^W",true,"^@","~$clojure.test.check/legacy-result","^3","clojure/test/check.cljc","^7",30,"^13",["^Y",[["^1L"]]],"^14",null,"^15",["^Y",[null,null]],"^5",1,"^16",false,"^4",43,"^17",["^?",[null,"^1D","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^6",43,"^19",1,"^1:",true,"^X",["^Y",["^Z",["^Y",[["^1L"]]]]],"^11","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",59,"^5",7,"^6",59,"^7",18,"^X",["^Y",["^Z",["^Y",[["~$num-tests","^1<","~$&",["^ ","~:keys",["^1@","~$max-size","^10"],"~:or",["^ ","^1S",200,"^10",["^Y",["~$constantly",null]]]]]]]]],"^11","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^16",true,"~:fixed-arity",2,"^19",2,"^13",[["^Y",["^1Q","^1<",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^X",["^Y",[["^1Q","^1<","~$&",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^15",["^Y",[null]]]],"^@","~$clojure.test.check/quick-check","^3","clojure/test/check.cljc","^7",18,"^1V",["^ ","^16",true,"^1W",2,"^19",2,"^13",[["^Y",["^1Q","^1<",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^X",["^Y",[["^1Q","^1<","~$&",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^15",["^Y",[null]]],"^13",[["^Y",["^1Q","^1<",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^14",null,"^1W",2,"^15",["^Y",[null]],"^5",1,"^16",true,"~:methods",[["^ ","^1W",2,"^16",true,"~:tag",["^?",["^1D","^18"]]]],"^4",59,"^17","^1D","^6",59,"^19",2,"^1:",true,"^X",["^Y",[["^1Q","^1<","~$&",["^ ","^1R",["^1@","^1S","^10"],"^1T",["^ ","^1S",200,"^10",["^Y",["^1U",null]]]]]]],"^11","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^V",null,"^2",["^ ","^3","clojure/test/check.cljc","^4",146,"^5",8,"^6",146,"^7",23,"^W",true,"^X",["^Y",["^Z",["^Y",[["~$total-nodes-visited","~$depth","~$smallest","^1A"]]]]]],"^W",true,"^@","~$clojure.test.check/smallest-shrink","^3","clojure/test/check.cljc","^7",23,"^13",["^Y",[["^20","^21","^22","^1A"]]],"^14",null,"^15",["^Y",[null,null]],"^5",1,"^16",false,"^4",146,"^17","^18","^6",146,"^19",4,"^1:",true,"^X",["^Y",["^Z",["^Y",[["^20","^21","^22","^1A"]]]]]]],"~:require-macros",["^ ","^<","^<"],"~:cljs.analyzer/constants",["^ ","^O",["^?",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^2@","^2=","^2D","^2K","^2?","^2O","^2B","^2M","^27","^2A","^2J","^26","^2;","^2E","^2G","^2:","^2L","^2H","^2F","^2N","^2>","^29","^2C","^2I","^2<","^28"]],"~:flags",["^ ","^P",["^?",[]]],"~:js-deps",[],"~:deps",["^K","^<","^J","^M","^E","^G","^I"]]