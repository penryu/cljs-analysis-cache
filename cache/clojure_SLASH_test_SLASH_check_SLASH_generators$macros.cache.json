["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check/generators$macros.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",34],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core"],"~:use-macros",["^ ","~$let","~$clojure.test.check.generators"],"~:excludes",["~#set",["~$uuid","~$set","~$namespace","~$boolean","~$map","~$char","~$shuffle","^>","~$double","~$int","~$symbol","~$sorted-set","~$vector","~$not-empty","~$list","~$keyword","~$hash-map","~$byte","~$sequence","~$bytes"]],"~:name","~$clojure.test.check.generators$macros","~:imports",null,"~:requires",["^ ","~$gstring","~$goog.string","~$rose","~$clojure.test.check.rose-tree","^10","^10","^Z","^Z","^<","^<","~$goog","^11","~$clojure.test.check.random","^12","~$string","~$clojure.string","^14","^14","~$random","^12","~$core","^<"],"~:seen",["^A",["~:require","~:require-macros"]],"~:shadow/js-access-global",["^A",["Number","Math","isNaN","Error"]],"~:uses",null,"~:defs",["^ ","~$coll-distinct-by*",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",702,"^5",17,"^6",702,"^7",34,"~:private",true,"~:arglists",["~#list",["~$quote",["^1A",[["~$empty-coll","~$key-fn","~$shuffle-fn","~$gen","~$rng","~$size","~$num-elements","~$min-elements","~$max-tries","~$ex-fn"]]]]],"~:doc","Returns a rose tree."],"^1?",true,"^U","~$clojure.test.check.generators$macros/coll-distinct-by*","^3","clojure/test/check/generators$macros.cljc","^7",34,"~:method-params",["^1A",[["^1C","^1D","^1E","^1F","^1G","^1H","^1I","^1J","^1K","^1L"]]],"~:protocol-impl",null,"~:arglists-meta",["^1A",[null,null]],"^5",1,"~:variadic?",false,"^4",702,"~:ret-tag","~$clojure.test.check.rose-tree/RoseTree","^6",702,"~:max-fixed-arity",10,"~:fn-var",true,"^1@",["^1A",["^1B",["^1A",[["^1C","^1D","^1E","^1F","^1G","^1H","^1I","^1J","^1K","^1L"]]]]],"^1M","Returns a rose tree."],"~$gen-fmap",["^ ","~:no-doc",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",53,"^5",7,"^6",53,"^7",15,"^1@",["^1A",["^1B",["^1A",[["~$k",["^ ","~$h","~:gen"]]]]]],"^1M","Internal function.","^1X",true],"^U","~$clojure.test.check.generators$macros/gen-fmap","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["~$k","~$p__7827"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",53,"^1S","~$clojure.test.check.generators$macros/Generator","^6",53,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$k",["^ ","~$h","^1Y"]]]]]],"^1M","Internal function."],"^B",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1520,"^5",24,"^6",1520,"^7",28,"~:added","0.9.0"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/uuid","^3","clojure/test/check/generators$macros.cljc","^7",28,"^5",1,"^4",1520,"^6",1520,"~:tag","^20","^1M","Generates a random type-4 UUID. Does not shrink."],"^C",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",10,"~:top-fn",["^ ","^1R",false,"~:fixed-arity",2,"^1U",2,"^1O",[["^1F"],["^1F","~$opts"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",915,"^6",915,"^1@",["^1A",["^1B",["^1A",[["^1F"],["^1F","^26"]]]]],"^1M","Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/set","^3","clojure/test/check/generators$macros.cljc","^7",10,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1F"],["^1F","^26"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"~:methods",[["^ ","^25",1,"^1R",false,"^23","~$any"],["^ ","^25",2,"^1R",false,"^23","^20"]],"^4",915,"^6",915,"^1U",2,"^1V",true,"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1M","Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$one-of",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",345,"^5",7,"^6",345,"^7",13,"^1@",["^1A",["^1B",["^1A",[["~$generators"]]]]],"^1M","Creates a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"^U","~$clojure.test.check.generators$macros/one-of","^3","clojure/test/check/generators$macros.cljc","^7",13,"^1O",["^1A",[["^2;"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",345,"^1S","^20","^6",345,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2;"]]]]],"^1M","Creates a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"~$uniform-integer",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1098,"^5",17,"^6",1098,"^7",32,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$bit-count"]]]]],"^1M","Generates an integer uniformly in the range 0..(2^bit-count-1)."],"^1?",true,"^U","~$clojure.test.check.generators$macros/uniform-integer","^3","clojure/test/check/generators$macros.cljc","^7",32,"^1O",["^1A",[["^2>"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1098,"^1S","^20","^6",1098,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2>"]]]]],"^1M","Generates an integer uniformly in the range 0..(2^bit-count-1)."],"~$any-printable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1700,"^5",6,"^6",1700,"^7",19],"^U","~$clojure.test.check.generators$macros/any-printable","^3","clojure/test/check/generators$macros.cljc","^7",19,"^5",1,"^4",1700,"^6",1700,"^23","^20","^1M","Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)"],"~$large-integer**",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1027,"^5",17,"^6",1027,"^7",32,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$min","~$max"]]]]],"^1M","Like large-integer*, but assumes range includes zero."],"^1?",true,"^U","~$clojure.test.check.generators$macros/large-integer**","^3","clojure/test/check/generators$macros.cljc","^7",32,"^1O",["^1A",[["^2C","^2D"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1027,"^1S","^20","^6",1027,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2C","^2D"]]]]],"^1M","Like large-integer*, but assumes range includes zero."],"~$MIN_NEG_VALUE",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1095,"^5",16,"^6",1095,"^7",29,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/MIN_NEG_VALUE","^3","clojure/test/check/generators$macros.cljc","^7",29,"^5",1,"^4",1095,"^6",1095,"^23","~$number"],"~$calc-long",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",225,"^5",8,"^6",225,"^7",17,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$factor","~$lower","~$upper"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/calc-long","^3","clojure/test/check/generators$macros.cljc","^7",17,"^1O",["^1A",[["^2J","^2K","^2L"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",225,"^1S","^2H","^6",225,"^1U",3,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2J","^2K","^2L"]]]]]],"~$vector-distinct",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",22,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",815,"^6",815,"^1@",["^1A",["^1B",["^1A",[["^1F"],["^1F","^26"]]]]],"^1M","Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/vector-distinct","^3","clojure/test/check/generators$macros.cljc","^7",22,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1F"],["^1F","^26"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","^20"]],"^4",815,"^6",815,"^1U",2,"^1V",true,"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1M","Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$double-exp-and-sign",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1165,"^5",17,"^6",1165,"^7",36,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$lower-bound","~$upper-bound"]]]]],"^1M","Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds."],"^1?",true,"^U","~$clojure.test.check.generators$macros/double-exp-and-sign","^3","clojure/test/check/generators$macros.cljc","^7",36,"^1O",["^1A",[["^2Q","^2R"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1165,"^6",1165,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2Q","^2R"]]]]],"^1M","Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds."],"~$MIN_INTEGER",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",999,"^5",16,"^6",999,"^7",27,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/MIN_INTEGER","^3","clojure/test/check/generators$macros.cljc","^7",27,"^5",1,"^4",999,"^6",999,"^23","^2H"],"^E",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",518,"^5",6,"^6",518,"^7",13],"^U","~$clojure.test.check.generators$macros/boolean","^3","clojure/test/check/generators$macros.cljc","^7",13,"^5",1,"^4",518,"^6",518,"^23","^20","^1M","Generates one of `true` or `false`. Shrinks to `false`."],"~$list-distinct",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",20,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",840,"^6",840,"^1@",["^1A",["^1B",["^1A",[["^1F"],["^1F","^26"]]]]],"^1M","Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/list-distinct","^3","clojure/test/check/generators$macros.cljc","^7",20,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1F"],["^1F","^26"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","^20"]],"^4",840,"^6",840,"^1U",2,"^1V",true,"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1M","Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$string-alphanumeric",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1430,"^5",6,"^6",1430,"^7",25],"^U","~$clojure.test.check.generators$macros/string-alphanumeric","^3","clojure/test/check/generators$macros.cljc","^7",25,"^5",1,"^4",1430,"^6",1430,"^23","^20","^1M","Generates alphanumeric strings."],"^F",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",963,"^5",7,"^6",963,"^7",10,"^1@",["^1A",["^1B",["^1A",[["~$key-gen","~$val-gen"],["^2[","^30","^26"]]]]],"^1M","Creates a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception","^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^2[","^30"],["^2[","^30","^26"]],"^1@",["^1A",[["^2[","^30"],["^2[","^30","^26"]]],"^1Q",["^1A",[null,null]]]],"^U","~$clojure.test.check.generators$macros/map","^3","clojure/test/check/generators$macros.cljc","^7",10,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^2[","^30"],["^2[","^30","^26"]],"^1@",["^1A",[["^2[","^30"],["^2[","^30","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^2[","^30"],["^2[","^30","^26"]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^20"]],"^4",963,"^6",963,"^1U",3,"^1V",true,"^1@",["^1A",[["^2[","^30"],["^2[","^30","^26"]]],"^1M","Creates a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception"],"~$simple-type",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1560,"^5",6,"^6",1560,"^7",17],"^U","~$clojure.test.check.generators$macros/simple-type","^3","clojure/test/check/generators$macros.cljc","^7",17,"^5",1,"^4",1560,"^6",1560,"^23","^20","^1M","Generates a variety of scalar types."],"^G",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1379,"^5",6,"^6",1379,"^7",10],"^U","~$clojure.test.check.generators$macros/char","^3","clojure/test/check/generators$macros.cljc","^7",10,"^5",1,"^4",1379,"^6",1379,"^23","^20","^1M","Generates character from 0-255."],"~$any-equatable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1705,"^5",25,"^6",1705,"^7",38,"^21","0.10.0"],"^21","0.10.0","^U","~$clojure.test.check.generators$macros/any-equatable","^3","clojure/test/check/generators$macros.cljc","^7",38,"^5",1,"^4",1705,"^6",1705,"^23","^20","^1M","Like any, but only generates objects that can be equal to other objects (e.g., do\n  not contain a NaN)"],"~$pos-int",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",561,"^5",30,"^6",561,"^7",37,"~:deprecated","0.10.0"],"^U","~$clojure.test.check.generators$macros/pos-int","^3","clojure/test/check/generators$macros.cljc","^7",37,"^5",1,"^4",561,"^38","0.10.0","^6",561,"^23","^20","^1M","Deprecated - use gen/nat instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonnegative integers bounded by the generator's `size` parameter."],"~$bind",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",125,"^5",7,"^6",125,"^7",11,"^1@",["^1A",["^1B",["^1A",[["~$generator","~$f"]]]]],"^1M","Creates a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality."],"^U","~$clojure.test.check.generators$macros/bind","^3","clojure/test/check/generators$macros.cljc","^7",11,"^1O",["^1A",[["^3;","~$f"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",125,"^1S","^20","^6",125,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3;","~$f"]]]]],"^1M","Creates a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality."],"~$symbol-ns",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1498,"^5",3,"^6",1498,"^7",12,"^21","0.5.9"],"^21","0.5.9","^U","~$clojure.test.check.generators$macros/symbol-ns","^3","clojure/test/check/generators$macros.cljc","^7",12,"^5",1,"^4",1496,"^6",1498,"^23","^20","^1M","Generates symbols with namespaces."],"^29",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1696,"^5",6,"^6",1696,"^7",9],"^U","~$clojure.test.check.generators$macros/any","^3","clojure/test/check/generators$macros.cljc","^7",9,"^5",1,"^4",1696,"^6",1696,"^23","^20","^1M","A recursive generator that will generate many different, often nested, values"],"~$hashable?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1580,"^5",20,"^6",1580,"^7",29,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/hashable?","^3","clojure/test/check/generators$macros.cljc","^7",29,"^1O",["^1A",[["~$x"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",4,"^1R",false,"^4",1580,"^1S","^E","^6",1580,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^H",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",638,"^5",3,"^6",638,"^7",10,"^21","0.6.0","^1@",["^1A",["^1B",["^1A",[["~$coll"]]]]],"^1M","Creates a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector."],"^21","0.6.0","^U","~$clojure.test.check.generators$macros/shuffle","^3","clojure/test/check/generators$macros.cljc","^7",10,"^1O",["^1A",[["^3B"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",636,"^1S","^20","^6",638,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3B"]]]]],"^1M","Creates a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector."],"~$container-type",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1588,"^5",7,"^6",1588,"^7",21,"^1@",["^1A",["^1B",["^1A",[["~$inner-type"]]]]]],"^U","~$clojure.test.check.generators$macros/container-type","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["^3E"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1588,"^1S","^20","^6",1588,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3E"]]]]]],"~$long->large-integer",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1006,"^5",17,"^6",1006,"^7",36,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^2>","~$x","^2C","^2D"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/long->large-integer","^3","clojure/test/check/generators$macros.cljc","^7",36,"^1O",["^1A",[["^2>","~$x","^2C","^2D"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1006,"^1S",["^A",["^29","^2H"]],"^6",1006,"^1U",4,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2>","~$x","^2C","^2D"]]]]]],"~$s-pos-int",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",577,"^5",30,"^6",577,"^7",39,"^38","0.10.0"],"^U","~$clojure.test.check.generators$macros/s-pos-int","^3","clojure/test/check/generators$macros.cljc","^7",39,"^5",1,"^4",577,"^38","0.10.0","^6",577,"^23","^20","^1M","Deprecated - use (gen/fmap inc gen/nat) instead (see also gen/large-integer).\n\n  Generates positive integers bounded by the generator's `size` + 1"],"~$get-exponent",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1147,"^5",17,"^6",1147,"^7",29,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/get-exponent","^3","clojure/test/check/generators$macros.cljc","^7",29,"^1O",["^1A",[["~$x"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1147,"^1S",["^A",["^29","^2H"]],"^6",1147,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^>",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",14,"^24",["^ ","^1R",true,"^25",1,"^1U",1,"^1O",["^1A",[["^1A",["~$bindings","~$body"]]]],"^1@",["^1A",[["^3M","~$&","^3N"]]],"^1Q",["^1A",[null]]],"^5",11,"^4",1721,"~:macro",true,"^6",1721,"^1@",["^1A",["^1B",["^1A",[["^3M","~$&","^3N"]]]]],"^1M","Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \"users\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/let","^3","clojure/test/check/generators$macros.cljc","^7",14,"^24",["^ ","^1R",true,"^25",1,"^1U",1,"^1O",["^1A",[["^1A",["^3M","^3N"]]]],"^1@",["^1A",[["^3M","~$&","^3N"]]],"^1Q",["^1A",[null]]],"^1O",["^1A",[["^1A",["^3M","^3N"]]]],"^1P",null,"^25",1,"^1Q",["^1A",[null]],"^5",1,"^1R",true,"^28",[["^ ","^25",1,"^1R",true,"^23",["^A",["~$seq","~$cljs.core/IList"]]]],"^4",1721,"^3O",true,"^1S","^29","^6",1721,"^1U",1,"^1V",false,"^1@",["^1A",[["^3M","~$&","^3N"]]],"^1M","Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \"users\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))"],"~$char-symbol-noninitial",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1411,"^5",16,"^6",1411,"^7",38,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/char-symbol-noninitial","^3","clojure/test/check/generators$macros.cljc","^7",38,"^5",1,"^4",1411,"^6",1411,"^23","^20","^1M","Generates characters that can be the char following first of a keyword or symbol."],"~$any-printable-equatable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1710,"^5",25,"^6",1710,"^7",48,"^21","0.10.0"],"^21","0.10.0","^U","~$clojure.test.check.generators$macros/any-printable-equatable","^3","clojure/test/check/generators$macros.cljc","^7",48,"^5",1,"^4",1710,"^6",1710,"^23","^20","^1M","Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command), and only generates\n  objects that can be equal to other objects (e.g., do not contain a NaN)"],"^I",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1295,"^5",24,"^6",1295,"^7",30,"^21","0.9.0"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/double","^3","clojure/test/check/generators$macros.cljc","^7",30,"^5",1,"^4",1295,"^6",1295,"^23",["^A",["^20","^29","~$clj-nil"]],"^1M","Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control."],"~$MAX_POS_VALUE",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1094,"^5",16,"^6",1094,"^7",29,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/MAX_POS_VALUE","^3","clojure/test/check/generators$macros.cljc","^7",29,"^5",1,"^4",1094,"^6",1094,"^23","~$js"],"~$list-distinct-by",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",23,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",890,"^6",890,"^1@",["^1A",["^1B",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]]]],"^1M","Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/list-distinct-by","^3","clojure/test/check/generators$macros.cljc","^7",23,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^20"]],"^4",890,"^6",890,"^1U",3,"^1V",true,"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1M","Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$simple-type-printable-equatable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1573,"^5",25,"^6",1573,"^7",56,"^21","0.10.0"],"^21","0.10.0","^U","~$clojure.test.check.generators$macros/simple-type-printable-equatable","^3","clojure/test/check/generators$macros.cljc","^7",56,"^5",1,"^4",1573,"^6",1573,"^23","^20","^1M","Like gen/simple-type-printable, but only generates objects that\n  can be equal to other objects (e.g., not a NaN)."],"~$block-bounds",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1207,"^5",17,"^6",1207,"^7",29,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$exp","~$sign"]]]]],"^1M","Returns [low high], the smallest and largest numbers in the given\n  range."],"^1?",true,"^U","~$clojure.test.check.generators$macros/block-bounds","^3","clojure/test/check/generators$macros.cljc","^7",29,"^1O",["^1A",[["^45","^46"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1207,"^1S","~$cljs.core/IVector","^6",1207,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^45","^46"]]]]],"^1M","Returns [low high], the smallest and largest numbers in the given\n  range."],"~$char-alpha",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1401,"^5",6,"^6",1401,"^7",16],"^U","~$clojure.test.check.generators$macros/char-alpha","^3","clojure/test/check/generators$macros.cljc","^7",16,"^5",1,"^4",1401,"^6",1401,"^23","^20","^1M","Generates alpha characters."],"~$generator?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",30,"^5",7,"^6",30,"^7",17,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]],"^1M","Test if `x` is a generator. Generators should be treated as opaque values."],"^U","~$clojure.test.check.generators$macros/generator?","^3","clojure/test/check/generators$macros.cljc","^7",17,"^1O",["^1A",[["~$x"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",30,"^1S","^E","^6",30,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]],"^1M","Test if `x` is a generator. Generators should be treated as opaque values."],"~$char-symbol-special",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1407,"^5",16,"^6",1407,"^7",35,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/char-symbol-special","^3","clojure/test/check/generators$macros.cljc","^7",35,"^5",1,"^4",1407,"^6",1407,"^23","^20","^1M","Generates non-alphanumeric characters that can be in a symbol."],"~$sample-seq",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",153,"^5",7,"^6",153,"^7",17,"^1@",["^1A",["^1B",["^1A",[["^3;"],["^3;","~$max-size"]]]]],"^1M","Returns an infinite sequence of realized values from `generator`.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.","^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^3;"],["^3;","^4@"]],"^1@",["^1A",[["^3;"],["^3;","^4@"]]],"^1Q",["^1A",[null,null]]]],"^U","~$clojure.test.check.generators$macros/sample-seq","^3","clojure/test/check/generators$macros.cljc","^7",17,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^3;"],["^3;","^4@"]],"^1@",["^1A",[["^3;"],["^3;","^4@"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^3;"],["^3;","^4@"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","~$cljs.core/LazySeq"]],"^4",153,"^6",153,"^1U",2,"^1V",true,"^1@",["^1A",[["^3;"],["^3;","^4@"]]],"^1M","Returns an infinite sequence of realized values from `generator`.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators."],"^J",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",554,"^5",30,"^6",554,"^7",33,"^38","0.10.0"],"^U","~$clojure.test.check.generators$macros/int","^3","clojure/test/check/generators$macros.cljc","^7",33,"^5",1,"^4",554,"^38","0.10.0","^6",554,"^23","^20","^1M","Deprecated - use gen/small-integer instead.\n\n  Generates a positive or negative integer bounded by the generator's\n  `size` parameter."],"~$gen-pure",["^ ","^1X",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",45,"^5",7,"^6",45,"^7",15,"^1@",["^1A",["^1B",["^1A",[["~$value"]]]]],"^1M","Internal function.","^1X",true],"^U","~$clojure.test.check.generators$macros/gen-pure","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["^4E"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",45,"^1S","^20","^6",45,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4E"]]]]],"^1M","Internal function."],"~$recursive-gen",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1641,"^5",3,"^6",1641,"^7",16,"^21","0.5.9","^1@",["^1A",["^1B",["^1A",[["~$container-gen-fn","~$scalar-gen"]]]]],"^1M","This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/small-integer]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))"],"^21","0.5.9","^U","~$clojure.test.check.generators$macros/recursive-gen","^3","clojure/test/check/generators$macros.cljc","^7",16,"^1O",["^1A",[["^4H","^4I"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1639,"^1S","^20","^6",1641,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4H","^4I"]]]]],"^1M","This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/small-integer]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))"],"~$char-alpha-numeric",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1395,"^5",3,"^6",1395,"^7",21,"^38","0.6.0"],"^U","~$clojure.test.check.generators$macros/char-alpha-numeric","^3","clojure/test/check/generators$macros.cljc","^7",21,"^5",1,"^4",1394,"^38","0.6.0","^6",1395,"^23","^20","^1M","Deprecated - use char-alphanumeric instead.\n\n  Generates alphanumeric characters."],"~$backwards-shrinking-significand",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1138,"^5",16,"^6",1138,"^7",47,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/backwards-shrinking-significand","^3","clojure/test/check/generators$macros.cljc","^7",47,"^5",1,"^4",1138,"^6",1138,"^23","^20","^1M","Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible)."],"~$return",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",106,"^5",7,"^6",106,"^7",13,"^1@",["^1A",["^1B",["^1A",[["^4E"]]]]],"^1M","Creates a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)"],"^U","~$clojure.test.check.generators$macros/return","^3","clojure/test/check/generators$macros.cljc","^7",13,"^1O",["^1A",[["^4E"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",106,"^1S","^20","^6",106,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4E"]]]]],"^1M","Creates a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)"],"~$gen-bind",["^ ","^1X",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",61,"^5",7,"^6",61,"^7",15,"^1@",["^1A",["^1B",["^1A",[[["^ ","~$h","^1Y"],"~$k"]]]]],"^1M","Internal function.","^1X",true],"^U","~$clojure.test.check.generators$macros/gen-bind","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["~$p__7831","~$k"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",61,"^1S","^20","^6",61,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[[["^ ","~$h","^1Y"],"~$k"]]]]],"^1M","Internal function."],"~$scale",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",302,"^5",7,"^6",302,"^7",12,"^1@",["^1A",["^1B",["^1A",[["~$f","^3;"]]]]],"^1M","Creates a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])","^21","0.8.0"],"^21","0.8.0","^U","~$clojure.test.check.generators$macros/scale","^3","clojure/test/check/generators$macros.cljc","^7",12,"^1O",["^1A",[["~$f","^3;"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",302,"^1S","^20","^6",302,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$f","^3;"]]]]],"^1M","Creates a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])"],"~$+-or---digit?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1446,"^5",8,"^6",1446,"^7",21,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$c","~$d"]]]]],"^1M","Returns true if c is \\+ or \\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers."],"^1?",true,"^U","~$clojure.test.check.generators$macros/+-or---digit?","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["~$c","~$d"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1446,"^1S","^E","^6",1446,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$c","~$d"]]]]],"^1M","Returns true if c is \\+ or \\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers."],"^K",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1488,"^5",6,"^6",1488,"^7",12],"^U","~$clojure.test.check.generators$macros/symbol","^3","clojure/test/check/generators$macros.cljc","^7",12,"^5",1,"^4",1488,"^6",1488,"^23","^20","^1M","Generates symbols without namespaces."],"~$such-that-helper",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",419,"^5",8,"^6",419,"^7",24,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$pred","^1F",["^ ","~:keys",["^1L","^1K"]],"^1G","^1H"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/such-that-helper","^3","clojure/test/check/generators$macros.cljc","^7",24,"^1O",["^1A",[["^4Z","^1F","~$p__7871","^1G","^1H"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",419,"^1S","^1T","^6",419,"^1U",5,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4Z","^1F",["^ ","^4[",["^1L","^1K"]],"^1G","^1H"]]]]]],"~$double-finite",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1219,"^5",17,"^6",1219,"^7",30,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^2Q","^2R"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/double-finite","^3","clojure/test/check/generators$macros.cljc","^7",30,"^1O",["^1A",[["^2Q","^2R"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1219,"^1S",["^A",["^20","^29"]],"^6",1219,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2Q","^2R"]]]]]],"~$pick",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",360,"^5",8,"^6",360,"^7",12,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$likelihoods","~$n"]]]]],"^1M","Returns an index into the `likelihoods` sequence."],"^1?",true,"^U","~$clojure.test.check.generators$macros/pick","^3","clojure/test/check/generators$macros.cljc","^7",12,"^1O",["^1A",[["^55","~$n"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",360,"^1S","^2H","^6",360,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^55","~$n"]]]]],"^1M","Returns an index into the `likelihoods` sequence."],"~$char-symbol-initial",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1417,"^5",16,"^6",1417,"^7",35,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/char-symbol-initial","^3","clojure/test/check/generators$macros.cljc","^7",35,"^5",1,"^4",1417,"^6",1417,"^23","^20","^1M","Generates characters that can be the first char of a keyword or symbol."],"~$char-alphanumeric",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1387,"^5",6,"^6",1387,"^7",23],"^U","~$clojure.test.check.generators$macros/char-alphanumeric","^3","clojure/test/check/generators$macros.cljc","^7",23,"^5",1,"^4",1387,"^6",1387,"^23","^20","^1M","Generates alphanumeric characters."],"~$make-size-range-seq",["^ ","^1X",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",147,"^5",7,"^6",147,"^7",26,"^1@",["^1A",["^1B",["^1A",[["^4@"]]]]],"^1M","Internal function.","^1X",true],"^U","~$clojure.test.check.generators$macros/make-size-range-seq","^3","clojure/test/check/generators$macros.cljc","^7",26,"^1O",["^1A",[["^4@"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",147,"^1S",["^A",["^29","~$cljs.core/Cycle"]],"^6",147,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4@"]]]]],"^1M","Internal function."],"~$choose",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",316,"^5",7,"^6",316,"^7",13,"^1@",["^1A",["^1B",["^1A",[["^2K","^2L"]]]]],"^1M","Creates a generator that generates integer numbers uniformly in\n     the range `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)"],"^U","~$clojure.test.check.generators$macros/choose","^3","clojure/test/check/generators$macros.cljc","^7",13,"^1O",["^1A",[["^2K","^2L"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",316,"^1S","^20","^6",316,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^2K","^2L"]]]]],"^1M","Creates a generator that generates integer numbers uniformly in\n     the range `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)"],"~$string-ascii",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1426,"^5",6,"^6",1426,"^7",18],"^U","~$clojure.test.check.generators$macros/string-ascii","^3","clojure/test/check/generators$macros.cljc","^7",18,"^5",1,"^4",1426,"^6",1426,"^23","^20","^1M","Generates ascii strings."],"^L",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",17,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",939,"^6",939,"^1@",["^1A",["^1B",["^1A",[["^1F"],["^1F","^26"]]]]],"^1M","Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/sorted-set","^3","clojure/test/check/generators$macros.cljc","^7",17,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^1F"],["^1F","^26"]],"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1F"],["^1F","^26"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","^20"]],"^4",939,"^6",939,"^1U",2,"^1V",true,"^1@",["^1A",[["^1F"],["^1F","^26"]]],"^1M","Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$make-gen",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",35,"^5",8,"^6",35,"^7",16,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$generator-fn"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/make-gen","^3","clojure/test/check/generators$macros.cljc","^7",16,"^1O",["^1A",[["^5D"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",35,"^1S","^20","^6",35,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^5D"]]]]]],"~$Generator",["^ ","~:num-fields",1,"~:protocols",["^A",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^U","^20","^3","clojure/test/check/generators$macros.cljc","^7",21,"~:type",true,"^5",12,"~:internal-ctor",true,"^4",28,"~:record",true,"^6",28,"^23","~$function","~:skip-protocol-flag",["^A",["^5I","^5J","^5K","^5L","^5M","^5N","^5O","^5P","^5Q","^5R","^5S","^5T","^5U","^5V","^5W"]]],"~$frequency",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",369,"^5",7,"^6",369,"^7",16,"^1@",["^1A",["^1B",["^1A",[["~$pairs"]]]]],"^1M","Creates a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"^U","~$clojure.test.check.generators$macros/frequency","^3","clojure/test/check/generators$macros.cljc","^7",16,"^1O",["^1A",[["^62"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",369,"^1S","^20","^6",369,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^62"]]]]],"^1M","Creates a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"~$small-integer",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",547,"^5",25,"^6",547,"^7",38,"^21","0.10.0"],"^21","0.10.0","^U","~$clojure.test.check.generators$macros/small-integer","^3","clojure/test/check/generators$macros.cljc","^7",38,"^5",1,"^4",547,"^6",547,"^23","^20","^1M","Generates a positive or negative integer bounded by the generator's\n  `size` parameter. Shrinks to zero."],"~$double*",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1253,"^5",7,"^6",1253,"^7",14,"^1@",["^1A",["^1B",["^1A",[[["^ ","^4[",["~$infinite?","~$NaN?","^2C","^2D"],"~:or",["^ ","^67",true,"^68",true]]]]]]],"^1M","Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity.","^21","0.9.0"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/double*","^3","clojure/test/check/generators$macros.cljc","^7",14,"^1O",["^1A",[["~$p__7990"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1253,"^1S",["^A",["^20","^29","^3X"]],"^6",1253,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[[["^ ","^4[",["^67","^68","^2C","^2D"],"^69",["^ ","^67",true,"^68",true]]]]]]],"^1M","Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity."],"~$generate",["^ ","^1>",null,"^2",["^ ","^21","0.8.0","^3","clojure/test/check/generators$macros.cljc","^7",15,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^3;"],["^3;","^1H"],["^3;","^1H","~$seed"]],"^1@",["^1A",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]]],"^1Q",["^1A",[null,null,null]]],"^5",7,"^4",182,"^6",182,"^1@",["^1A",["^1B",["^1A",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]]]]],"^1M","Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer"],"^21","0.8.0","^U","~$clojure.test.check.generators$macros/generate","^3","clojure/test/check/generators$macros.cljc","^7",15,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]],"^1@",["^1A",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]]],"^1Q",["^1A",[null,null,null]]],"^1O",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^29"]],"^4",182,"^6",182,"^1U",3,"^1V",true,"^1@",["^1A",[["^3;"],["^3;","^1H"],["^3;","^1H","^6="]]],"^1M","Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer"],"~$distinct-by?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",744,"^5",17,"^6",744,"^7",29,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$f","^3B"]]]]],"^1M","Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections."],"^1?",true,"^U","~$clojure.test.check.generators$macros/distinct-by?","^3","clojure/test/check/generators$macros.cljc","^7",29,"^1O",["^1A",[["~$f","^3B"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",744,"^1S",["^A",["^E","^29"]],"^6",744,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$f","^3B"]]]]],"^1M","Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections."],"~$sized",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",251,"^5",7,"^6",251,"^7",12,"^1@",["^1A",["^1B",["^1A",[["~$sized-gen"]]]]],"^1M","Creates a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n  Examples:\n\n      ;; generates vectors of booleans where the length always exactly\n      ;; matches the `size` parameter\n      (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n      => ([]\n          [false]\n          [true true]\n          [false true false]\n          [false true true true]\n          [false false true true false]\n          [false true false true true false]\n          [true false true true true false false]\n          [true true false false false true false false]\n          [false false false true true false true false true])"],"^U","~$clojure.test.check.generators$macros/sized","^3","clojure/test/check/generators$macros.cljc","^7",12,"^1O",["^1A",[["^6B"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",251,"^1S","^20","^6",251,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^6B"]]]]],"^1M","Creates a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n  Examples:\n\n      ;; generates vectors of booleans where the length always exactly\n      ;; matches the `size` parameter\n      (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n      => ([]\n          [false]\n          [true true]\n          [false true false]\n          [false true true true]\n          [false false true true false]\n          [false true false true true false]\n          [true false true true true false false]\n          [true true false false false true false false]\n          [false false false true true false true false true])"],"~$s-neg-int",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",583,"^5",30,"^6",583,"^7",39,"^38","0.10.0"],"^U","~$clojure.test.check.generators$macros/s-neg-int","^3","clojure/test/check/generators$macros.cljc","^7",39,"^5",1,"^4",583,"^38","0.10.0","^6",583,"^23","^20","^1M","Deprecated - use (gen/fmap (comp dec -) gen/nat) instead (see also gen/large-integer).\n\n  Generates negative integers bounded by the generator's `size` + 1"],"~$nat",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",540,"^5",6,"^6",540,"^7",9],"^U","~$clojure.test.check.generators$macros/nat","^3","clojure/test/check/generators$macros.cljc","^7",9,"^5",1,"^4",540,"^6",540,"^23","^20","^1M","Generates non-negative integers bounded by the generator's `size`\n  parameter. Shrinks to zero."],"~$simple-type-equatable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1568,"^5",25,"^6",1568,"^7",46,"^21","0.10.0"],"^21","0.10.0","^U","~$clojure.test.check.generators$macros/simple-type-equatable","^3","clojure/test/check/generators$macros.cljc","^7",46,"^5",1,"^4",1568,"^6",1568,"^23","^20","^1M","Like gen/simple-type, but only generates objects that can be\n  equal to other objects (e.g., not a NaN)."],"~$coll-distinct-by",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",769,"^5",17,"^6",769,"^7",33,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^1C","^1D","~$allows-dupes?","~$ordered?","^1F",["^ ","^4[",["^1I","^1J","~$max-elements","^1K","^1L"],"^69",["^ ","^1K",10,"^1L",["^1A",["~$fn*",["~$p1__7923#"],["^1A",["~$ex-info","Couldn't generate enough distinct elements!","^6O"]]]]]]]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/coll-distinct-by","^3","clojure/test/check/generators$macros.cljc","^7",33,"^1O",["^1A",[["^1C","^1D","^6K","^6L","^1F","~$p__7930"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",769,"^1S","^20","^6",769,"^1U",6,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1C","^1D","^6K","^6L","^1F",["^ ","^4[",["^1I","^1J","^6M","^1K","^1L"],"^69",["^ ","^1K",10,"^1L",["^1A",["^6N",["^6O"],["^1A",["^6P","Couldn't generate enough distinct elements!","^6O"]]]]]]]]]]]],"~$resize-symbolish-generator",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1467,"^5",17,"^6",1467,"^7",43,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$g"]]]]],"^1M","Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable."],"^1?",true,"^U","~$clojure.test.check.generators$macros/resize-symbolish-generator","^3","clojure/test/check/generators$macros.cljc","^7",43,"^1O",["^1A",[["~$g"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1467,"^1S","^20","^6",1467,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$g"]]]]],"^1M","Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable."],"~$the-shuffle-fn",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",751,"^5",17,"^6",751,"^7",31,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^1G","^3B"]]]]],"^1M","Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function."],"^1?",true,"^U","~$clojure.test.check.generators$macros/the-shuffle-fn","^3","clojure/test/check/generators$macros.cljc","^7",31,"^1O",["^1A",[["^1G","^3B"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",751,"^1S",["^A",[null,"~$clj","^29"]],"^6",751,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1G","^3B"]]]]],"^1M","Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function."],"~$tuple",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",522,"^5",7,"^6",522,"^7",12,"^1@",["^1A",["^1B",["^1A",[["~$&","^2;"]]]]],"^1M","Creates a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the vector will never shrink in count.\n\n  Examples:\n\n      (def t (gen/tuple gen/small-integer gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))","^24",["^ ","^1R",true,"^25",0,"^1U",0,"^1O",[["^1A",["^2;"]]],"^1@",["^1A",[["~$&","^2;"]]],"^1Q",["^1A",[null]]]],"^U","~$clojure.test.check.generators$macros/tuple","^3","clojure/test/check/generators$macros.cljc","^7",12,"^24",["^ ","^1R",true,"^25",0,"^1U",0,"^1O",[["^1A",["^2;"]]],"^1@",["^1A",[["~$&","^2;"]]],"^1Q",["^1A",[null]]],"^1O",[["^1A",["^2;"]]],"^1P",null,"^25",0,"^1Q",["^1A",[null]],"^5",1,"^1R",true,"^28",[["^ ","^25",0,"^1R",true,"^23","^20"]],"^4",522,"^1S","^29","^6",522,"^1U",0,"^1V",true,"^1@",["^1A",[["~$&","^2;"]]],"^1M","Creates a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the vector will never shrink in count.\n\n  Examples:\n\n      (def t (gen/tuple gen/small-integer gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))"],"~$lazy-random-states",["^ ","^1X",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",72,"^5",7,"^6",72,"^7",25,"^1@",["^1A",["^1B",["^1A",[["~$rr"]]]]],"^1M","Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators.","^1X",true],"^U","~$clojure.test.check.generators$macros/lazy-random-states","^3","clojure/test/check/generators$macros.cljc","^7",25,"^1O",["^1A",[["^6["]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",72,"^1S","^4B","^6",72,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^6["]]]]],"^1M","Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators."],"~$map->Generator",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^7",21,"^5",12,"^5Y",true,"~:factory","~:map","^4",28,"^6",28,"^1@",["^1A",["^1B",["^1A",[["~$G__7725"]]]]],"^1M","Factory function for clojure.test.check.generators$macros/Generator, taking a map of keywords to field values."],"^U","~$clojure.test.check.generators$macros/map->Generator","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["^74"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^5Y",true,"^1R",false,"^72","^73","^4",28,"^1S","^20","^6",28,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^74"]]]]],"^1M","Factory function for clojure.test.check.generators$macros/Generator, taking a map of keywords to field values."],"~$shrink-2",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",511,"^5",7,"^6",511,"^7",15,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Creates a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level)."],"^U","~$clojure.test.check.generators$macros/shrink-2","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["^1F"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",511,"^1S","^20","^6",511,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Creates a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level)."],"~$string-alpha-numeric",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1435,"^5",3,"^6",1435,"^7",23,"^38","0.6.0"],"^U","~$clojure.test.check.generators$macros/string-alpha-numeric","^3","clojure/test/check/generators$macros.cljc","^7",23,"^5",1,"^4",1434,"^38","0.6.0","^6",1435,"^23","^20","^1M","Deprecated - use string-alphanumeric instead.\n\n  Generates alphanumeric strings."],"~$resize",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",280,"^5",7,"^6",280,"^7",13,"^1@",["^1A",["^1B",["^1A",[["~$n","^3;"]]]]],"^1M","Creates a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})"],"^U","~$clojure.test.check.generators$macros/resize","^3","clojure/test/check/generators$macros.cljc","^7",13,"^1O",["^1A",[["~$n","^3;"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",280,"^1S","^20","^6",280,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$n","^3;"]]]]],"^1M","Creates a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})"],"~$digit?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1441,"^5",8,"^6",1441,"^7",14,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$d"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/digit?","^3","clojure/test/check/generators$macros.cljc","^7",14,"^1O",["^1A",[["~$d"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1441,"^1S","^29","^6",1441,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$d"]]]]]],"~$scalb",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1117,"^5",17,"^6",1117,"^7",22,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$x","^45"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/scalb","^3","clojure/test/check/generators$macros.cljc","^7",22,"^1O",["^1A",[["~$x","^45"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1117,"^1S","^2H","^6",1117,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$x","^45"]]]]]],"~$neg-int",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",569,"^5",30,"^6",569,"^7",37,"^38","0.10.0"],"^U","~$clojure.test.check.generators$macros/neg-int","^3","clojure/test/check/generators$macros.cljc","^7",37,"^5",1,"^4",569,"^38","0.10.0","^6",569,"^23","^20","^1M","Deprecated - use (gen/fmap - gen/nat) instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonpositive integers bounded by the generator's `size` parameter."],"^13",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1422,"^5",6,"^6",1422,"^7",12],"^U","~$clojure.test.check.generators$macros/string","^3","clojure/test/check/generators$macros.cljc","^7",12,"^5",1,"^4",1422,"^6",1422,"^23","^20","^1M","Generates strings. May generate unprintable characters."],"^M",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",589,"^5",7,"^6",589,"^7",13,"^1@",["^1A",["^1B",["^1A",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]]]]],"^1M","Creates a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter.","^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]],"^1@",["^1A",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]]],"^1Q",["^1A",[null,null,null]]]],"^U","~$clojure.test.check.generators$macros/vector","^3","clojure/test/check/generators$macros.cljc","^7",13,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]],"^1@",["^1A",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]]],"^1Q",["^1A",[null,null,null]]],"^1O",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^20"],["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^20"]],"^4",589,"^6",589,"^1U",3,"^1V",true,"^1@",["^1A",[["^3;"],["^3;","^1I"],["^3;","^1J","^6M"]]],"^1M","Creates a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter."],"~$large-integer",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1061,"^5",24,"^6",1061,"^7",37,"^21","0.9.0"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/large-integer","^3","clojure/test/check/generators$macros.cljc","^7",37,"^5",1,"^4",1061,"^6",1061,"^23","^29","^1M","Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control."],"~$keyword-ns",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1482,"^5",3,"^6",1482,"^7",13,"^21","0.5.9"],"^21","0.5.9","^U","~$clojure.test.check.generators$macros/keyword-ns","^3","clojure/test/check/generators$macros.cljc","^7",13,"^5",1,"^4",1480,"^6",1482,"^23","^20","^1M","Generates keywords with namespaces."],"^N",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",480,"^5",7,"^6",480,"^7",16,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])"],"^U","~$clojure.test.check.generators$macros/not-empty","^3","clojure/test/check/generators$macros.cljc","^7",16,"^1O",["^1A",[["^1F"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",480,"^1S","^29","^6",480,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])"],"~$gen-raw-long",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",992,"^5",16,"^6",992,"^7",28,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/gen-raw-long","^3","clojure/test/check/generators$macros.cljc","^7",28,"^5",1,"^4",992,"^6",992,"^23","^20","^1M","Generates a single uniformly random long, does not shrink."],"~$NAN",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1096,"^5",16,"^6",1096,"^7",19,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/NAN","^3","clojure/test/check/generators$macros.cljc","^7",19,"^5",1,"^4",1096,"^6",1096,"^23","^3["],"~$elements",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",408,"^5",7,"^6",408,"^7",15,"^1@",["^1A",["^1B",["^1A",[["^3B"]]]]],"^1M","Creates a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)"],"^U","~$clojure.test.check.generators$macros/elements","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["^3B"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",408,"^1S","^20","^6",408,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3B"]]]]],"^1M","Creates a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)"],"~$default-such-that-opts",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",433,"^5",3,"^6",433,"^7",25,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/default-such-that-opts","^3","clojure/test/check/generators$macros.cljc","^7",25,"^5",1,"^4",432,"^6",433,"^23","^5V"],"~$fifty-two-bit-reverse",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1122,"^5",17,"^6",1122,"^7",38,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$n"]]]]],"^1M","Bit-reverses an integer in the range [0, 2^52)."],"^1?",true,"^U","~$clojure.test.check.generators$macros/fifty-two-bit-reverse","^3","clojure/test/check/generators$macros.cljc","^7",38,"^1O",["^1A",[["~$n"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1122,"^1S","^2H","^6",1122,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$n"]]]]],"^1M","Bit-reverses an integer in the range [0, 2^52)."],"~$POS_INFINITY",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1092,"^5",16,"^6",1092,"^7",28,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/POS_INFINITY","^3","clojure/test/check/generators$macros.cljc","^7",28,"^5",1,"^4",1092,"^6",1092,"^23","^3["],"~$sample",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",166,"^5",7,"^6",166,"^7",13,"^1@",["^1A",["^1B",["^1A",[["^3;"],["^3;","~$num-samples"]]]]],"^1M","Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.","^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^3;"],["^3;","^7V"]],"^1@",["^1A",[["^3;"],["^3;","^7V"]]],"^1Q",["^1A",[null,null]]]],"^U","~$clojure.test.check.generators$macros/sample","^3","clojure/test/check/generators$macros.cljc","^7",13,"^24",["^ ","^1R",false,"^25",2,"^1U",2,"^1O",[["^3;"],["^3;","^7V"]],"^1@",["^1A",[["^3;"],["^3;","^7V"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^3;"],["^3;","^7V"]],"^1P",null,"^25",2,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",1,"^1R",false,"^23","^29"],["^ ","^25",2,"^1R",false,"^23","^4B"]],"^4",166,"^6",166,"^1U",2,"^1V",true,"^1@",["^1A",[["^3;"],["^3;","^7V"]]],"^1M","Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators."],"~$randomized",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1629,"^5",17,"^6",1629,"^7",27,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$func"]]]]],"^1M","Like sized, but passes an rng instead of a size."],"^1?",true,"^U","~$clojure.test.check.generators$macros/randomized","^3","clojure/test/check/generators$macros.cljc","^7",27,"^1O",["^1A",[["^7Y"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1629,"^1S","^20","^6",1629,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^7Y"]]]]],"^1M","Like sized, but passes an rng instead of a size."],"~$NEG_INFINITY",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1093,"^5",16,"^6",1093,"^7",28,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/NEG_INFINITY","^3","clojure/test/check/generators$macros.cljc","^7",28,"^5",1,"^4",1093,"^6",1093,"^23","^3["],"^O",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",620,"^5",7,"^6",620,"^7",11,"^1@",["^1A",["^1B",["^1A",[["^3;"]]]]],"^1M","Like `vector`, but generates lists."],"^U","~$clojure.test.check.generators$macros/list","^3","clojure/test/check/generators$macros.cljc","^7",11,"^1O",["^1A",[["^3;"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",620,"^1S","^20","^6",620,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3;"]]]]],"^1M","Like `vector`, but generates lists."],"~$large-integer*",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1039,"^5",7,"^6",1039,"^7",21,"^1@",["^1A",["^1B",["^1A",[[["^ ","^4[",["^2C","^2D"]]]]]]],"^1M","Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)","^21","0.9.0"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/large-integer*","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["~$p__7956"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1039,"^1S","^29","^6",1039,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[[["^ ","^4[",["^2C","^2D"]]]]]]],"^1M","Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)"],"~$abs",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1002,"^5",17,"^6",1002,"^7",20,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/abs","^3","clojure/test/check/generators$macros.cljc","^7",20,"^1O",["^1A",[["~$x"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1002,"^1S","^29","^6",1002,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$x"]]]]]],"^P",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1474,"^5",6,"^6",1474,"^7",13],"^U","~$clojure.test.check.generators$macros/keyword","^3","clojure/test/check/generators$macros.cljc","^7",13,"^5",1,"^4",1474,"^6",1474,"^23","^20","^1M","Generates keywords without namespaces."],"~$gen-tuple",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",84,"^5",8,"^6",84,"^7",17,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$gens"]]]]],"^1M","Takes a collection of generators and returns a generator of vectors."],"^1?",true,"^U","~$clojure.test.check.generators$macros/gen-tuple","^3","clojure/test/check/generators$macros.cljc","^7",17,"^1O",["^1A",[["^89"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",84,"^1S","^20","^6",84,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^89"]]]]],"^1M","Takes a collection of generators and returns a generator of vectors."],"~$bind-helper",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",116,"^5",8,"^6",116,"^7",19,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$f"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/bind-helper","^3","clojure/test/check/generators$macros.cljc","^7",19,"^1O",["^1A",[["~$f"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",116,"^1S","^5[","^6",116,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$f"]]]]]],"^Q",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",665,"^5",7,"^6",665,"^7",15,"^1@",["^1A",["^1B",["^1A",[["~$&","~$kvs"]]]]],"^1M","Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})","^24",["^ ","^1R",true,"^25",0,"^1U",0,"^1O",[["^1A",["^8="]]],"^1@",["^1A",[["~$&","^8="]]],"^1Q",["^1A",[null]]]],"^U","~$clojure.test.check.generators$macros/hash-map","^3","clojure/test/check/generators$macros.cljc","^7",15,"^24",["^ ","^1R",true,"^25",0,"^1U",0,"^1O",[["^1A",["^8="]]],"^1@",["^1A",[["~$&","^8="]]],"^1Q",["^1A",[null]]],"^1O",[["^1A",["^8="]]],"^1P",null,"^25",0,"^1Q",["^1A",[null]],"^5",1,"^1R",true,"^28",[["^ ","^25",0,"^1R",true,"^23","^20"]],"^4",665,"^1S","^29","^6",665,"^1U",0,"^1V",true,"^1@",["^1A",[["~$&","^8="]]],"^1M","Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})"],"~$call-gen",["^ ","^1X",true,"^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",39,"^5",7,"^6",39,"^7",15,"^1@",["^1A",["^1B",["^1A",[[["^ ","^5D","^1Y"],"~$rnd","^1H"]]]]],"^1M","Internal function.","^1X",true],"^U","~$clojure.test.check.generators$macros/call-gen","^3","clojure/test/check/generators$macros.cljc","^7",15,"^1O",["^1A",[["~$p__7824","^8@","^1H"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",39,"^1S","^29","^6",39,"^1U",3,"^1V",true,"^1@",["^1A",["^1B",["^1A",[[["^ ","^5D","^1Y"],"^8@","^1H"]]]]],"^1M","Internal function."],"~$rand-range",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",246,"^5",8,"^6",246,"^7",18,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^8@","^2K","^2L"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/rand-range","^3","clojure/test/check/generators$macros.cljc","^7",18,"^1O",["^1A",[["^8@","^2K","^2L"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",246,"^1S","^2H","^6",246,"^1U",3,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^8@","^2K","^2L"]]]]]],"~$ratio",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1504,"^5",6,"^6",1504,"^7",11],"^U","~$clojure.test.check.generators$macros/ratio","^3","clojure/test/check/generators$macros.cljc","^7",11,"^5",1,"^4",1504,"^6",1504,"^23","^20","^1M","Generates a small ratio (or integer) using gen/small-integer. Shrinks\n  toward simpler ratios, which may be larger or smaller."],"~$transient-set-contains?",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",695,"^5",17,"^6",695,"^7",40,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$s","~$k"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/transient-set-contains?","^3","clojure/test/check/generators$macros.cljc","^7",40,"^1O",["^1A",[["~$s","~$k"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",695,"^1S","^E","^6",695,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$s","~$k"]]]]]],"~$such-that",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",440,"^5",7,"^6",440,"^7",16,"^1@",["^1A",["^1B",["^1A",[["^4Z","^1F"],["^4Z","^1F","~$max-tries-or-opts"]]]]],"^1M","Creates a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/small-integer))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception","^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^4Z","^1F"],["^4Z","^1F","^8J"]],"^1@",["^1A",[["^4Z","^1F"],["^4Z","^1F","^8J"]]],"^1Q",["^1A",[null,null]]]],"^U","~$clojure.test.check.generators$macros/such-that","^3","clojure/test/check/generators$macros.cljc","^7",16,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^4Z","^1F"],["^4Z","^1F","^8J"]],"^1@",["^1A",[["^4Z","^1F"],["^4Z","^1F","^8J"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^4Z","^1F"],["^4Z","^1F","^8J"]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^20"]],"^4",440,"^6",440,"^1U",3,"^1V",true,"^1@",["^1A",[["^4Z","^1F"],["^4Z","^1F","^8J"]]],"^1M","Creates a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/small-integer))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception"],"~$shrink-int",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",209,"^5",8,"^6",209,"^7",18,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$integer"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/shrink-int","^3","clojure/test/check/generators$macros.cljc","^7",18,"^1O",["^1A",[["^8M"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",209,"^1S","^4B","^6",209,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^8M"]]]]]],"~$random-pseudofactoring",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1611,"^5",19,"^6",1611,"^7",41,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$n","^1G"]]]]],"^1M","Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n)."],"^1?",true,"^U","~$clojure.test.check.generators$macros/random-pseudofactoring","^3","clojure/test/check/generators$macros.cljc","^7",41,"^1O",["^1A",[["~$n","^1G"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",3,"^1R",false,"^4",1611,"^1S","^6W","^6",1611,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$n","^1G"]]]]],"^1M","Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n)."],"~$vector-distinct-by",["^ ","^1>",null,"^2",["^ ","^21","0.9.0","^3","clojure/test/check/generators$macros.cljc","^7",25,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^5",7,"^4",865,"^6",865,"^1@",["^1A",["^1B",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]]]],"^1M","Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^21","0.9.0","^U","~$clojure.test.check.generators$macros/vector-distinct-by","^3","clojure/test/check/generators$macros.cljc","^7",25,"^24",["^ ","^1R",false,"^25",3,"^1U",3,"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1Q",["^1A",[null,null]]],"^1O",[["^1D","^1F"],["^1D","^1F","^26"]],"^1P",null,"^25",3,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^28",[["^ ","^25",2,"^1R",false,"^23","^29"],["^ ","^25",3,"^1R",false,"^23","^20"]],"^4",865,"^6",865,"^1U",3,"^1V",true,"^1@",["^1A",[["^1D","^1F"],["^1D","^1F","^26"]]],"^1M","Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$swap",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",632,"^5",8,"^6",632,"^7",12,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^3B",["~$i1","~$i2"]]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/swap","^3","clojure/test/check/generators$macros.cljc","^7",12,"^1O",["^1A",[["^3B","~$p__7896"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",632,"^1S",["^A",["^6W","^29"]],"^6",632,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^3B",["^8T","^8U"]]]]]]],"~$size->max-leaf-count",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1603,"^5",17,"^6",1603,"^7",37,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^1H"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/size->max-leaf-count","^3","clojure/test/check/generators$macros.cljc","^7",37,"^1O",["^1A",[["^1H"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1603,"^1S","^2H","^6",1603,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1H"]]]]]],"~$int-rose-tree",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",213,"^5",8,"^6",213,"^7",21,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["^4E"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/int-rose-tree","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["^4E"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",213,"^1S","^1T","^6",213,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^4E"]]]]]],"~$fmap",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",94,"^5",7,"^6",94,"^7",11,"^1@",["^1A",["^1B",["^1A",[["~$f","^1F"]]]]],"^1M","Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\"0\" \"1\" \"0\" \"1\" \"4\" \"3\" \"6\" \"6\" \"4\" \"2\")\n\n  Also see gen/let for a macro with similar functionality."],"^U","~$clojure.test.check.generators$macros/fmap","^3","clojure/test/check/generators$macros.cljc","^7",11,"^1O",["^1A",[["~$f","^1F"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",94,"^1S","^20","^6",94,"^1U",2,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$f","^1F"]]]]],"^1M","Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\"0\" \"1\" \"0\" \"1\" \"4\" \"3\" \"6\" \"6\" \"4\" \"2\")\n\n  Also see gen/let for a macro with similar functionality."],"~$MAX_INTEGER",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",997,"^5",16,"^6",997,"^7",27,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/MAX_INTEGER","^3","clojure/test/check/generators$macros.cljc","^7",27,"^5",1,"^4",997,"^6",997,"^23","^2H"],"~$->Generator",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^7",21,"^5",12,"^5Y",true,"^72","~:positional","^4",28,"^6",28,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Positional factory function for clojure.test.check.generators$macros/Generator."],"^U","~$clojure.test.check.generators$macros/->Generator","^3","clojure/test/check/generators$macros.cljc","^7",21,"^1O",["^1A",[["^1F"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^5Y",true,"^1R",false,"^72","^95","^4",28,"^1S","^20","^6",28,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Positional factory function for clojure.test.check.generators$macros/Generator."],"~$no-shrink",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",501,"^5",7,"^6",501,"^7",16,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Creates a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain."],"^U","~$clojure.test.check.generators$macros/no-shrink","^3","clojure/test/check/generators$macros.cljc","^7",16,"^1O",["^1A",[["^1F"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",501,"^1S","^20","^6",501,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^1F"]]]]],"^1M","Creates a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain."],"~$char-ascii",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1383,"^5",6,"^6",1383,"^7",16],"^U","~$clojure.test.check.generators$macros/char-ascii","^3","clojure/test/check/generators$macros.cljc","^7",16,"^5",1,"^4",1383,"^6",1383,"^23","^20","^1M","Generates only ascii characters."],"~$simple-type-printable",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1564,"^5",6,"^6",1564,"^7",27],"^U","~$clojure.test.check.generators$macros/simple-type-printable","^3","clojure/test/check/generators$macros.cljc","^7",27,"^5",1,"^4",1564,"^6",1564,"^23","^20","^1M","Generates a variety of scalar types, with printable strings."],"~$base-simple-type",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1555,"^5",17,"^6",1555,"^7",33,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$double-gen","~$char-gen","~$string-gen"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/base-simple-type","^3","clojure/test/check/generators$macros.cljc","^7",33,"^1O",["^1A",[["^9>","^9?","^9@"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",1555,"^1S","^20","^6",1555,"^1U",3,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["^9>","^9?","^9@"]]]]]],"~$halfs",["^ ","^1>",null,"^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",205,"^5",8,"^6",205,"^7",13,"^1?",true,"^1@",["^1A",["^1B",["^1A",[["~$n"]]]]]],"^1?",true,"^U","~$clojure.test.check.generators$macros/halfs","^3","clojure/test/check/generators$macros.cljc","^7",13,"^1O",["^1A",[["~$n"]]],"^1P",null,"^1Q",["^1A",[null,null]],"^5",1,"^1R",false,"^4",205,"^1S","^4B","^6",205,"^1U",1,"^1V",true,"^1@",["^1A",["^1B",["^1A",[["~$n"]]]]]],"~$symbol-name-or-namespace",["^ ","^2",["^ ","^3","clojure/test/check/generators$macros.cljc","^4",1457,"^5",16,"^6",1457,"^7",40,"^1?",true],"^1?",true,"^U","~$clojure.test.check.generators$macros/symbol-name-or-namespace","^3","clojure/test/check/generators$macros.cljc","^7",40,"^5",1,"^4",1457,"^6",1457,"^23","^20","^1M","Generates a namespace string for a symbol/keyword."]],"^19",["^ ","^<","^<","^16","^<","^?","^?"],"~:cljs.analyzer/constants",["^ ","^17",["^A",["~:max-tries","~:min","~$clojure.test.check.generators/generator?","~:max-tries-or-opts","~:pred","~:else","^1Y","~$do","^1F","~$clojure.test.check.generators/bind","~$if","~:infinite?","~$cljs.core/let","~$clojure.test.check.generators/let","~:max","~$val__8026__auto__","~$/","~$cljs.core/fn","~$clojure.test.check.generators/return","~:max-elements","~:ex-fn","~:num-elements","~:min-elements","~:NaN?"]],"~:order",["^1Y","^1F","^9X","^9G","^9K","^9L","^9J","^9Y","^9Z","^9W","^9H","^9S","^9P","^9[","~$/","^9Q","^9T","^9M","^9O","^9I","^9V","^9N","^9U","^9R"]],"~:flags",["^ ","^18",["^A",[]],"^19",["^A",[]]],"~:js-deps",["^ "],"~:deps",["^11","^<","^14","^12","^10","^Z"]]