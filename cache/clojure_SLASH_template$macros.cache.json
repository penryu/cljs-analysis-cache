["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/template$macros.cljc","~:line",27,"~:column",3,"~:end-line",27,"~:end-column",19,"~:doc","Macros that expand to repeated copies of a template expression.","~:author","Stuart Sierra"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.test","~$cljs.test"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.template$macros","~:imports",null,"~:requires",["^ ","~$clojure.walk","^F","~$walk","^F","~$cljs.core","^H","~$goog","^I"],"~:seen",["^A",["~:require"]],"~:shadow/js-access-global",["^A",["Error"]],"~:uses",null,"~:defs",["^ ","~$apply-template",["^ ","~:protocol-inline",null,"^2",["^ ","^3","clojure/template$macros.cljc","^4",30,"^5",7,"^6",30,"^7",21,"~:arglists",["~#list",["~$quote",["^R",[["~$argv","~$expr","~$values"]]]]],"^8","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"^B","~$clojure.template$macros/apply-template","^3","clojure/template$macros.cljc","^7",21,"~:method-params",["^R",[["^T","^U","^V"]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^5",1,"~:variadic?",false,"^4",30,"~:ret-tag","~$any","^6",30,"~:max-fixed-arity",3,"~:fn-var",true,"^Q",["^R",["^S",["^R",[["^T","^U","^V"]]]]],"^8","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"~$do-template",["^ ","^P",null,"^2",["^ ","^3","clojure/template$macros.cljc","^7",22,"~:top-fn",["^ ","^[",true,"~:fixed-arity",2,"^12",2,"^X",["^R",[["^R",["^T","^U","^V"]]]],"^Q",["^R",[["^T","^U","~$&","^V"]]],"^Z",["^R",[null]]],"^5",11,"^4",45,"~:macro",true,"^6",45,"^Q",["^R",["^S",["^R",[["^T","^U","~$&","^V"]]]]],"^8","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"],"^B","~$clojure.template$macros/do-template","^3","clojure/template$macros.cljc","^7",22,"^15",["^ ","^[",true,"^16",2,"^12",2,"^X",["^R",[["^R",["^T","^U","^V"]]]],"^Q",["^R",[["^T","^U","~$&","^V"]]],"^Z",["^R",[null]]],"^X",["^R",[["^R",["^T","^U","^V"]]]],"^Y",null,"^16",2,"^Z",["^R",[null]],"^5",1,"^[",true,"~:methods",[["^ ","^16",2,"^[",true,"~:tag",["^A",["~$seq","~$cljs.core/IList"]]]],"^4",45,"^17",true,"^10","^11","^6",45,"^12",2,"^13",false,"^Q",["^R",[["^T","^U","~$&","^V"]]],"^8","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"]],"~:require-macros",["^ ","^H","^H"],"~:cljs.analyzer/constants",["^ ","^J",["^A",["~$do"]],"~:order",["^1?"]],"~:flags",["^ ","^K",["^A",[]]],"~:js-deps",["^ "],"~:deps",["^I","^H","^F"]]